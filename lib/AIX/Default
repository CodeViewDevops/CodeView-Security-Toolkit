#!/bin/sh

. "$APP_PATH/lib/AIX/include.sh"

TARGET_OS="AIX"

BASE_IDS="1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 44 45 46 47"

SUBNAME[1]="Roteamento habilitado desnecessariamente"
SUBCODE[1]="4008"
apply_1() {
	local file="/etc/rc.net"
	local cmd="/usr/sbin/no"
	
	val=`$cmd -a | sed -n 's/^ *ipforwarding *= *\(.*\)$/\1/p'`

	backupFile "$file" "data" "$cmd -o ipforwarding=$val"

	$cmd -o ipforwarding=0
	setLine "$file" "$cmd -o ipforwarding" "$cmd -o ipforwarding=0" "ipforwarding=0"
	return
}

SUBNAME[2]="Broadcasts diretos permitidos"
SUBCODE[2]="4010"
apply_2() {
	local file="/etc/rc.tcpip"
	local cmd="/usr/sbin/no"

	val=`$cmd -a | sed -n 's/^ *directed_broadcast *= *\(.*\)$/\1/p'`

	backupFile "$file" "data" "$cmd -o directed_broadcast=$val"

	$cmd -o directed_broadcast=0
	setLine "$file" "$cmd -o directed_broadcast" "$cmd -o directed_broadcast=0" "directed_broadcast=0"
	return
}

SUBNAME[3]="Ausência de controle sobre broadcasts ICMP"
SUBCODE[3]="4011"
apply_3() {
	local file="/etc/rc.tcpip"
	local cmd="/usr/sbin/no"

	val=`$cmd -a | sed -n 's/^ *bcastping *= *\(.*\)$/\1/p'`

	backupFile "$file" "data" "$cmd -o bcastping=$val"

	$cmd -o bcastping=0
	setLine "$file" "$cmd -o bcastping" "$cmd -o bcastping=0" "bcastping=0"
	return
}

SUBNAME[4]="Permissões de diretórios temporários incorretas"
SUBCODE[4]="4012"
apply_4() {
	local files="/tmp /var/tmp /var/locks /var/msgs /var/news /var/ifor /var/preserve"

	files=`ls -ld $files`

	[ -z "$files" ] && return 22

	for file in $files; do
		if [ -d "$file" ]; then
			backupFile "$file" "perm"
			chmod 1777 "$file"
		fi
	done

	return
}

SUBNAME[5]="Permissões no diretório /etc incorretas"
SUBCODE[5]="4015"
apply_5() {
	setEtcPerm
	return
}

SUBNAME[6]="Umask padrão não restritivo"
SUBCODE[6]="4016"
apply_6() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_UMASK" ]; then
		MISSED_VAR="BASE_UMASK"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a umask | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "umask=${BASE_UMASK}"
		local val=`lssec -f $file -s default -a umask | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_UMASK" ]; then

			chsec -f $file -s default -a "umask=${BASE_UMASK}"
			local val=`lssec -f $file -s default -a umask | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a umask | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "umask=${BASE_UMASK}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "umask=${BASE_UMASK}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[7]="Daemon Syslogd desabilitado"
SUBCODE[7]="4017"
apply_7() {
	local file="/etc/rc.tcpip"	

	backupFile "$file" "data"

	setLine "$file" "^[ \t]*start /usr/sbin/syslogd" "start /usr/sbin/syslogd \"\$src_running\""
	return
}

SUBNAME[8]="Uso de relações de confiança"
SUBCODE[8]="4031"
apply_8() {
	setTrust
	return
}

SUBNAME[9]="Tempo máximo entre alterações de senhas alto ou indefinido"
SUBCODE[9]="4038"
apply_9() {

        ######################################################
        # Initializing variables
        ######################################################
        local file="/etc/security/user"
        local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u | egrep -v "^[ \t]*root[ \t]*$"`
        local vulnerable="no"
        ######################################################

        ######################################################
        # Checking the baseline's variable
        ######################################################
        if [ -z "$BASE_MAXAGE" ]; then

                MISSED_VAR="BASE_MAXAGE"
                return 33
        fi
        ######################################################

        ######################################################
        # Backing up the target file
        ######################################################
        backupFile "$file" "data"
        ######################################################

        ######################################################
        # Skipping ignored users
        ######################################################
        [ -n "$BASE_MAXAGE_IGNORED" -o -n "$BASE_USERS_PASSWORD_NOT_EXPIRE" ] && {

                local ignored_users=`echo $BASE_MAXAGE_IGNORED $BASE_USERS_PASSWORD_NOT_EXPIRE | tr " " "\n" | sort -u`
                for ignored_user in ${ignored_users}; do

                        local found_ignored_user=`echo "$userS_temp" | tr " " "\n" | egrep "^[ \t]*$ignored_user[ \t]*$"`
                        if [ -n "$found_ignored_user" ]; then

                                #checking current value (can be displayed from default stanza)
                                local temp_val=`lssec -f $file -s $found_ignored_user -a maxage | awk -F"=" '{ print $2 }'`
                                chsec -f $file -s $found_ignored_user -a "maxage=${temp_val}"
                                userS_temp=`echo "$userS_temp" | tr " " "\n" | egrep -v "^[ \t]*$ignored_user[ \t]*$"`
                        fi

                done
        }
        ######################################################

        ######################################################
        # Applying the default stanza only and getting the
        # result
        ######################################################
        local val=`lssec -f $file -s default -a maxage | awk -F= '{ print $2 }'`

        if [ -z "$val" -o "$val" != "$BASE_MAXAGE" ]; then

                chsec -f $file -s default -a maxage=${BASE_MAXAGE}
                local val=`lssec -f $file -s default -a maxage | awk -F= '{ print $2 }'`
                vulnerable="yes"
        fi
        ######################################################

        ######################################################
        # Applying all vulnerable stanzas
        ######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a maxage | awk -F"=" '{ print $2 }'`
		if [ -z "$temp_val" -o "$temp_val" != "$BASE_MAXAGE" ] ; then

			chsec -f $file -s $user_temp -a maxage=${BASE_MAXAGE}
			vulnerable="yes"
		fi
        done
        ######################################################

        ######################################################
        # Checking the return code
        ######################################################
        if [ "$vulnerable" = "yes" ]; then

                unset vulnerable
                return
        else
                unset vulnerable
                return $CODE_CONFORMITY
        fi
        ######################################################
}

SUBNAME[10]="Tempo entre expiração e bloqueio da conta alto ou indefinido"
SUBCODE[10]="4041"
apply_10() {

        ######################################################
        # Initializing variables
        ######################################################
        local file="/etc/security/user"
        local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u | egrep -v "^[ \t]*root[ \t]*$"`
        local vulnerable="no"
        ######################################################

        ######################################################
        # Checking the baseline's variable
        ######################################################
        if [ -z "$BASE_MAXEXP" ]; then

                MISSED_VAR="BASE_MAXEXP"
                return 33
        fi
        ######################################################

        ######################################################
        # Backing up the target file
        ######################################################
        backupFile "$file" "data"
        ######################################################

        ######################################################
        # Skipping ignored users
        ######################################################
        [ -n "$BASE_MAXEXP_IGNORED" -o -n "$BASE_USERS_PASSWORD_NOT_EXPIRE" ] && {

                local ignored_users=`echo $BASE_MAXEXP_IGNORED $BASE_USERS_PASSWORD_NOT_EXPIRE | tr " " "\n" | sort -u`
                for ignored_user in ${ignored_users}; do

                        local found_ignored_user=`echo "$userS_temp" | tr " " "\n" | egrep "^[ \t]*$ignored_user[ \t]*$"`
                        if [ -n "$found_ignored_user" ]; then

                                #checking current value (can be displayed from default stanza)
                                local temp_val=`lssec -f $file -s $found_ignored_user -a maxexpired | awk -F"=" '{ print $2 }'`
                                chsec -f $file -s $found_ignored_user -a "maxexpired=${temp_val}"
                                userS_temp=`echo "$userS_temp" | tr " " "\n" | egrep -v "^[ \t]*$ignored_user[ \t]*$"`
                        fi

                done
        }
        ######################################################

        ######################################################
        # Applying the default stanza only and getting the
        # result
        ######################################################
        local val=`lssec -f $file -s default -a maxexpired | awk -F= '{ print $2 }'`

        if [ -z "$val" -o "$val" != "$BASE_MAXEXP" ]; then

                chsec -f $file -s default -a maxexpired=${BASE_MAXEXP}
                local val=`lssec -f $file -s default -a maxexpired | awk -F= '{ print $2 }'`
                vulnerable="yes"
        fi
        ######################################################

        ######################################################
        # Applying all vulnerable stanzas
        ######################################################
        for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a maxexpired | awk -F"=" '{ print $2 }'`
		if [ -z "$temp_val" -o "$temp_val" != "$BASE_MAXEXP" ] ; then

			chsec -f $file -s $user_temp -a maxexpired=${BASE_MAXEXP}
			vulnerable="yes"
		fi
        done
        ######################################################

        ######################################################
        # Checking the return code
        ######################################################
        if [ "$vulnerable" = "yes" ]; then

                unset vulnerable
                return
        else
                unset vulnerable
                return $CODE_CONFORMITY
        fi
        ######################################################
}

SUBNAME[11]="Mínimo de letras não definido para senha de usuários"
SUBCODE[11]="4056"
apply_11() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_MINALPHA" ]; then
		MISSED_VAR="BASE_MINALPHA"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a minalpha | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "minalpha=${BASE_MINALPHA}"
		local val=`lssec -f $file -s default -a minalpha | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_MINALPHA" ]; then

			chsec -f $file -s default -a "minalpha=${BASE_MINALPHA}"
			local val=`lssec -f $file -s default -a minalpha | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a minalpha | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "minalpha=${BASE_MINALPHA}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "minalpha=${BASE_MINALPHA}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[12]="Mínimo de caracteres especiais não definido para senha de usuários"
SUBCODE[12]="4057"
apply_12() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_MINOTHER" ]; then
		MISSED_VAR="BASE_MINOTHER"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a minother | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "minother=${BASE_MINOTHER}"
		local val=`lssec -f $file -s default -a minother | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_MINOTHER" ]; then

			chsec -f $file -s default -a "minother=${BASE_MINOTHER}"
			local val=`lssec -f $file -s default -a minother | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a minother | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "minother=${BASE_MINOTHER}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "minother=${BASE_MINOTHER}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[13]="Número de vezes que um caracter pode se repetir na senha não definido"
SUBCODE[13]="4058"
apply_13() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_MAXREPEATS" ]; then
		MISSED_VAR="BASE_MAXREPEATS"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a maxrepeats | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "maxrepeats=${BASE_MAXREPEATS}"
		local val=`lssec -f $file -s default -a maxrepeats | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_MAXREPEATS" ]; then

			chsec -f $file -s default -a "maxrepeats=${BASE_MAXREPEATS}"
			local val=`lssec -f $file -s default -a maxrepeats | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a maxrepeats | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "maxrepeats=${BASE_MAXREPEATS}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "maxrepeats=${BASE_MAXREPEATS}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[14]="Usuários de sistema com shell válido"
SUBCODE[14]="4051"
apply_14() {

        local file="/etc/security/login.cfg"
        local shell="/usr/bin/false"
        local fixed="0"
        local start_backup="0"

        [ -z "$BASE_NOSHELL" ] && {

                MISSED_VAR="BASE_NOSHELL"
                return 33
        }

        local shells=`lssec -f $file -s usw -a shells | awk -F= '{ print $2 }'`
        echo "$shells" | grep "$shell" > /dev/null 2> /dev/null
        local result="$?"

        [ "$result" -ne 0 ] && {

                backupFile "$file" "data"
                chsec -f $file -s usw -a "shells=$shells,$shell"
                local fixed="1"
        }

        local file="/etc/passwd"
        local valid_users=`awk -F: ' ( $1 !~ /^[ \t]*#|^[ \t]*$/ ) && ( $7 != "/usr/bin/false" ) { print $1 }' $file | sort -u`
        local user=""

        for user in ${BASE_NOSHELL}; do

                local result=`echo "$valid_users" | tr " " "\n" | egrep "^[ \t]*$user[ \t]*$"`
                [ -n "$result" ] && {

                        [ "$start_backup" -eq "0" ] && {

                                backupFile "$file" "data"
                                local start_backup="1"
                        }

                        /usr/sbin/usermod -s /usr/bin/false $user
                        local fixed="1"
                }
        done

        [ "$fixed" -eq "0" ] && return ${CODE_CONFORMITY}
        return ${CODE_OK}
}



SUBNAME[15]="Uso irrestrito do comando su"
SUBCODE[15]="4061"
apply_15() {
  # Check if the variables are defined on the baseline
	[ -z "$BASE_PRIVGROUP" ] && {
		MISSED_VAR="BASE_PRIVGROUP"
		return $CODE_MISSED_VAR
	}

  [ -z "$BASE_SU_USERS" ] && {
		MISSED_VAR="BASE_SU_USERS"
		return $CODE_MISSED_VAR
	}


	# Check if the group exists
	local group_id=`awk -F: -v GROUP=$BASE_PRIVGROUP 'match($1,GROUP) { print  $3 }' /etc/group`
	local group_exists=0
	if [ -n "$group_id" ]; then
  	group_exists=1
  fi


	# Check if all users in BASE_SU_USERS are in BASE_PRIVGROUP


	# Users who are in baseline but don't exist
	local inexistent_users=""
 
	[ "$group_exists" = "1" ] && {

		#
		# We need to replace linebreaks or commas in some variables
		# in order to use them in the "for" loops below. 
		#

		# space-separated list of users in the system
		local system_priv_users=`lsgroup $BASE_PRIVGROUP | awk '{ for (i=0; i<=NF; i++) { if (match($i,/^users=/)) { print $i } } }' | awk -F= '{ print $2 }' | sed 's/,/ /g'`

		# space-separated list of users in the baseline
		local bs_priv_users=`echo $BASE_SU_USERS | sed 's/\n/ /g'`


		local Old_IFS=$IFS
		IFS=" "

		# O(n^2) loop
		for system_user in "$system_priv_users"; do

			local found_user=0
			for bs_user in "$bs_priv_users"; do
				 if [ "$bs_user" = "$system_user" ]; then
				 		found_user=1
				 fi
			done
            
            if [ "$found_user" != "1" ]; then
				inexistent_users="$bs_user $inexistent_users"
			fi

 
		done

        IFS=$Old_IFS


     }

	#
  # Check root group permissions. (sugroups=$BASE_PRIVGROUP)
  # 
	local root_group_permissions_ok=0
	local root_group_permissions=`lsuser -f root|grep "^[[:blank:]]sugroups="|awk -F= '{ print $2 } '`
	[ "$root_group_permissions" = "$BASE_PRIVGROUP" ] && root_group_permissions_ok=1


  #
  # Check if su=true for root
  #
  local root_su_ok=0
  local root_su=`lsuser -f root|grep "^[[:blank:]]su="|awk -F= '{ print $2 } '`
	[ "$root_su" = "true" ] && root_su_ok=1 

	
	
	#
	# If group exists and users are ok and root permissions are ok, conformity.
	#
  [ "$group_exists" = "1" ] && [ -z "$inexistent_users" ] && [ "$root_group_permissions_ok" = "1" ] && [ "$root_su_ok" = "1" ] && return $CODE_CONFORMITY
	
	
	#
	#
  # The code below will run only if not in conformity!
  #
  #
	

	#
	# If not in conformity, backup
	#
    backupFile "/etc/group" "data"
    backupFile "/etc/security/group" "data"
    backupFile "/etc/security/user" "data"
    backupFile "/etc/passwd" "data"
 
	#
	# If group doesn't exist, create and add users to it.
	#
	[ "$group_exists" != "1" ] && {
		mkgroup $BASE_PRIVGROUP 2>> "$LOGE" || {
			[ $verbosity ] && echo "    Error while creating group $BASE_PRIVGROUP"
			echo "Error while creating group $BASE_PRIVGROUP" >> "$LOGE"
			
			return $CODE_ERROR
		}
  	
		# now that the group exists, we can set group_exists to 1
		group_exists=1
	}
	

	#
	# If users aren't alright and but group exists, set users.
	# This code also runs after creating the group above.
	#
	[ "$group_exists" = "1" ] && [ "$inexistent_users" != "" ] && {
			# comma-separated users that should be created in the system
			local bs_priv_users=`echo $BASE_SU_USERS | sed 's/\n/,/g' | sed 's/ /,/g'`
			
			chgroup users=$bs_priv_users $BASE_PRIVGROUP 2>> "$LOGE" || {
				[ $verbosity ] && echo "    Error while adding users to group $BASE_PRIVGROUP"
				echo "Error while adding users to group $BASE_PRIVGROUP" 2>> "$LOGE"
				return $CODE_ERROR
			}

	    # now that the users were added, we can change this variable too
			inexistent_users=""
	}


  #
	# If root permissions aren't ok, set it.
	#
	[ "$group_exists" = "1" ] && [ "$inexistent_users" = "" ] && {
		chuser su=true sugroups=$BASE_PRIVGROUP root 2>> "$LOGE" || {
		 	[ $verbosity ] && echo "    Error while setting sugroups for root"
		 	echo "Error while setting sugroups for root" >> "$LOGE"
		 	return $CODE_ERROR
		}
		return $CODE_OK	
	}


  return $CODE_ERROR

}

SUBNAME[16]="Compiladores CC e GCC disponíveis para todos"
SUBCODE[16]="4066"
apply_16() {
	setCompilerPerm
	return
}

SUBNAME[17]="Tempo entre logins incorretos baixo ou indefinido"
SUBCODE[17]="4067"
apply_17() {

        local file="/etc/security/login.cfg"

        if [ -z "$BASE_DELAY" ]; then

                MISSED_VAR="BASE_DELAY"
                return 33
        fi

        local result=`lssec -f $file -s default -a logindelay | awk -F= '{ print $2 }'`
        [ -n "$result" -a "$result" == "$BASE_DELAY" ] && return ${CODE_CONFORMITY}

        backupFile "$file" "data"
        chsec -f $file -s default -a "logindelay=${BASE_DELAY}"

        return ${CODE_OK}
}

SUBNAME[18]="Motd/Issue com informações sobre o sistema"
SUBCODE[18]="4029"
apply_18() {

	local file="/etc/motd"
	local cmd=""

	[ -z "$BASE_BANNER" ] && { 

		MISSED_VAR="BASE_BANNER"
		return ${CODE_MISSED_VAR}
	}

        if [ -f "$file" ]; then

                #Delete motd content
                if [ -n "$BASE_EMPTY_MOTD" -a "$BASE_EMPTY_MOTD" = "on" ]; then

                        echo "" > "$file"
                        return ${CODE_OK}
                else

                        file_content=`cat $file >> "$LOGE"`

                        [ "$file_content" = "$BASE_BANNER" ] && return ${CODE_CONFORMITY}

                        backupFile "$file" "data"
                        setContent "$file" "$BASE_BANNER"
                        return ${CODE_OK}
                fi
        else

                return ${CODE_CONFORMITY}
        fi
}

SUBNAME[19]="Tempo mínimo entre alterações de senhas alto"
SUBCODE[19]="4036"
apply_19() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_MINAGE" ]; then
		MISSED_VAR="BASE_MINAGE"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a minage | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "minage=${BASE_MINAGE}"
		local val=`lssec -f $file -s default -a minage | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_MINAGE" ]; then

			chsec -f $file -s default -a "minage=${BASE_MINAGE}"
			local val=`lssec -f $file -s default -a minage | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a minage | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "minage=${BASE_MINAGE}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "minage=${BASE_MINAGE}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[20]="Expiração de histórico de senhas pequena ou inexistente"
SUBCODE[20]="4049"
apply_20() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_HISTEXP" ]; then
		MISSED_VAR="BASE_HISTEXP"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a histexpire | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "histexpire=${BASE_HISTEXP}"
		local val=`lssec -f $file -s default -a histexpire | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_HISTEXP" ]; then

			chsec -f $file -s default -a "histexpire=${BASE_HISTEXP}"
			local val=`lssec -f $file -s default -a histexpire | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a histexpire | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "histexpire=${BASE_HISTEXP}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "histexpire=${BASE_HISTEXP}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[21]="Máquina vulnerável a SYN Floods"
SUBCODE[21]="4009"
apply_21() {
	local file="/etc/rc.net"
	local cmd="/usr/sbin/no"
	local version=`uname -a | awk '{ print $4 }'`
	local release=`uname -a | awk '{ print $3 }'`

	backupFile "$file" "data"

	###########################################################
	# Checking the AIX version and release before to apply it
	# For versions 5.2 and above, there is another way to
	# configure this item, as described in their documentation
	###########################################################
	case $version in
		# For version 5 and prior
        	[1..5])
        
			if [ "$version" = "5" ]; then
				# For releases 5.0 and 5.1
				if [ "$release" -lt 2 ]; then
					tmp_file=`mktemp /tmp/correction.XXXXXX`
					sed "/^\/\{0,1\}\([a-zA-Z0-9]\{1,\}\/\)\{0,\}no[[:blank:]]*-o[[:blank:]]*clean_partial_conns/d" $file > $tmp_file

					$cmd -o clean_partial_conns=1
					echo "$cmd -o clean_partial_conns=1" >> $tmp_file

					cat $tmp_file > $file

					rm -f $tmp_file
				else
					# For releases 5.2 and 5.3
					$cmd -p -o clean_partial_conns=1 >/dev/null 2>>$LOGE

				fi
			else

				# For versions prior to 5
				tmp_file=`mktemp /tmp/correction.XXXXXX`
				sed "/^\/\{0,1\}\([a-zA-Z0-9]\{1,\}\/\)\{0,\}no[[:blank:]]*-o[[:blank:]]*clean_partial_conns/d" $file > $tmp_file

				$cmd -o clean_partial_conns=1
				echo "$cmd -o clean_partial_conns=1" >> $tmp_file

				cat $tmp_file > $file

				rm -f $tmp_file
			fi
		;;

		# For versions 6 and above
		*)
			$cmd -p -o clean_partial_conns=1 >/dev/null 2>>$LOGE
		;;
	esac
	###########################################################

	return
}


SUBNAME[22]="SUID/SGID desnecessários"
SUBCODE[22]="4013"
apply_22() {
	setSid "/usr/bin /usr/sbin /usr/local/bin /usr/local/sbin /bin /sbin"
	return
}

SUBNAME[23]="Syslogd aceitando conexões externas"
SUBCODE[23]="4018"
apply_23() {
	local file="/etc/rc.tcpip"
	local cmd="start /usr/sbin/syslogd \"\$src_running\" -R"

	backupFile "$file" "data"
	
	setLine "$file" "^[ \t]*start /usr/sbin/syslogd" "$cmd"
	stopsrc -s "syslogd" && startsrc -a "-R" -s "syslogd"
	return
}

SUBNAME[24]="Serviços desnecessários em /etc/inittab"
SUBCODE[24]="4021"
apply_24() {

	local file="/etc/inittab"
	local BADINIT

	[ -z "$BASE_INITTAB_DENY" ] && {

		MISSED_VAR="BASE_INITTAB_DENY"
		return 33
	}

	for serv in `awk -F: ' $1 != "" { print $1 } ' $file`; do
	        
		for bad in $BASE_INITTAB_DENY; do
                
			[ "$serv" = "$bad" ] && BADINIT="$serv $BADINIT"
        	done
	done

	[ -z "$BADINIT" ] && return 22

	backupFile "$file" "data"

	for bad in $BADINIT; do

        	apply_service="0"
        	[ "$interactive" = "no" ] || {

        		yn "            [*] Service to be stopped: \"${bad}\". Apply?"
        		apply_service="$?"
        	}

        	[ "$apply_service" -eq "1" ] && {

        		continue
        	}

		stopsrc -s $bad
		setStr "$file" "^$bad" "^$bad" ":$bad"
		[ "$?" -ne "0" ] && return
	done

	return
}

SUBNAME[25]="Serviços desnecessários em rc.tcpip"
SUBCODE[25]="4025"
apply_25() {

	local file="/etc/rc.tcpip"
	local BADRC
	
	[ -z "$BASE_RCTCP_DENY" ] && {

		MISSED_VAR="BASE_RCTCP_DENY"
		return 33
	}

	for serv in `awk ' $1 == "start" { print $2 } ' $file`; do

		for bad in $BASE_RCTCP_DENY; do

			[ "$serv" = "$bad" ] && BADRC="$serv $BADRC"
		done
	done

	[ -z "$BADRC" ] && return 22
	backupFile "$file" "data"

	for bad in $BADRC; do

        	apply_service="0"
        	[ "$interactive" = "no" ] || {

        		yn "            [*] Service to be stopped: \"${bad}\". Apply?"
        		apply_service="$?"
        	}

        	[ "$apply_service" -eq "1" ] && {

        		continue
        	}

		stopsrc -s `basename $bad`
		setLine "$file" "$bad" "#"
	done

	return
}

SUBNAME[26]="Serviços inetd desnecessários"
SUBCODE[26]="4026"
apply_26() {

	local file="/etc/inetd.conf"
	local BADSERVICE

	# For debug reasons
	echo "BASE_INETD_DENY=\"$BASE_INETD_DENY\"" >> "$LOGF"
	echo "BASE_INETD_ALLOW=\"$BASE_INETD_ALLOW\"" >> "$LOGF"

  	if [ -n "$BASE_INETD_DENY" ]; then
    
		for serv in `awk ' $1 !~ /^#/ { print $1 } ' $file`; do
      
			for bad in $BASE_INETD_DENY; do
        
				[ "$serv" = "$bad" ] && {
          
					BADSERVICE="$serv $BADSERVICE"
          				break
        			}
      			done
    		done
  	else

    		if [ -n "$BASE_INETD_ALLOW" ]; then
      
			for serv in `awk ' $1 !~ /^#/ { print $1 } ' $file`; do
        
				ERR=1
        			for good in $BASE_INETD_ALLOW; do
          
					[ "$serv" = "$good" ] && {
            				
						unset ERR
            					break
          				}
        			done
        
				[ -n "$ERR" ] && BADSERVICE="$serv $BADSERVICE"
      			done
    		else
      
			MISSED_VAR="BASE_INETD_ALLOW BASE_INETD_DENY"
      			return $CODE_MISSED_VAR    
    		fi
  	fi

  	echo "BADSERVICE=\"$BADSERVICE\"" >> "$LOGF"
  	[ -z "$BADSERVICE" ] && return $CODE_CONFORMITY

  	backupFile "$file" "data"
  
  	for bad in $BADSERVICE; do
 
        	apply_service="0"
        	[ "$interactive" = "no" ] || {

        		yn "            [*] Service to be stopped: \"${bad}\". Apply?"
        		apply_service="$?"
        	}

        	[ "$apply_service" -eq "1" ] && {

        		continue
        	}

		tmp_file=`mktemp /tmp/correction.XXXXXX 2> "$LOGF"`
    		sed "s/^\([ \t]\{0,\}$bad[ \t]\{1,\}.\{1,\}\)/#\1/" $file 2> "$LOGF" > $tmp_file
    		cat $tmp_file > $file 2> "$LOGF"
    		rm -f $tmp_file 2> "$LOGF"
  	done
  
	return $CODE_OK

  # Try to restart the service
  #refresh -s inetd >/dev/null 1>/dev/null 2>/dev/null
  #local refresh_return=$?
	
  # If the command above wasn't able to  refresh inetd, maybe the inetd service is down.
  # Let's try to start it.
  #if [ $refresh_return -ne 0 ]; then
  #  echo "        Nao foi possivel reiniciar o inetd, provavelmente nao esta em execucao."
  #  return $CODE_OK
  #  fi
  #else
  #  echo "        Inetd reiniciado com sucesso"
  #  return $CODE_OK
  #fi
	
	
}

SUBNAME[27]="Usuários de sistema com senha válida"
SUBCODE[27]="4050"
apply_27() {

        local file="/etc/security/user"
        local fixed="0"
        local start_backup="0"

        [ -z "$BASE_NOPASS" ] && {

                MISSED_VAR="BASE_NOPASS"
                return 33
        }


        local valid_users=`lsuser -a account_locked ALL | awk ' $2 ~ /account_locked=false/ { print $1 }'`
        local user=""

        for user in ${BASE_NOPASS}; do

                local result=`echo "$valid_users" | tr " " "\n" | egrep "^[ \t]*$user[ \t]*$"`
                [ -n "$result" ] && {

                        [ "$start_backup" -eq "0" ] && {

                                backupFile "$file" "data"
                                local start_backup="1"
                        }

                        chuser account_locked=true $user
                        local fixed="1"
                }
        done

        [ "$fixed" -eq "0" ] && return ${CODE_CONFORMITY}
        return ${CODE_OK}
}

SUBNAME[28]="Login remoto como super-usuário habilitado"
SUBCODE[28]="4060"
apply_28() {
	local var
	local file="/etc/security/user"

	val=`lssec -f $file -s root -a rlogin | awk -F= ' print $2 '`
	
	[ "$val" = "false" ] && return 22
	
	backupFile "$file" "data"

	chsec -f /etc/security/user -s root -a "rlogin=false"
	return
}

SUBNAME[29]="Ausência de mensagem sobre restrição de acesso"
SUBCODE[29]="4030"
apply_29() {
	local file="/etc/security/login.cfg"

	[ -z "$BASE_RESTRICTMSG" ] && {
		MISSED_VAR="BASE_RESTRICTMSG"
		return 33
	}

        backupFile "$file" "data"

        # selecting only the users defined on baseline that exist on system.
        base_users=`user_exists "$BASE_AT_ALLOW"`
        [ -z "$base_users" ] && {
          echo "None of the users defined on baseline exist on system." >> $LOGF
          return $CODE_CONFORMITY
        }

        tmp_file=`mktemp /tmp/correction.XXXXXX`

        cat $file > $tmp_file
        sed '/^[[:blank:]]*herald[[:blank:]]*=/d' $file > $tmp_file

        PRINTF_MSG="        herald = \"${BASE_RESTRICTMSG}\""

        printf "%s\n" "`awk -v MSG="$PRINTF_MSG" '
        BEGIN {
                gsub(/[\n]/,"\\\n",MSG)
                gsub(/[\r]/,"\\\r",MSG)
                gsub(/[\t]/,"\\\t",MSG)
                DEFAULT_SESSION=0
                DEFAULT_SESSION_INDEX=0
        }

        {
                if(/^[ \t]*[a-zA-Z0-9_]+:[ \t]*$/ || /^[*]/ ) {
                       if(DEFAULT_SESSION==1) {
                                DEFAULT_SESSION=0
                                print "default:"
                                print MSG
				for(i=0;i<DEFAULT_SESSION_INDEX;i++) {
                                         print DEFAULT_MSGS[i]
                                }
                                DEFAULT_SESSION_INDEX=0
                        }
                }

                if(/^[ \t]*default:[ \t]*$/) {
                        DEFAULT_SESSION=1
                } else {
			if(DEFAULT_SESSION==1) {
                                DEFAULT_MSGS[DEFAULT_SESSION_INDEX++]=$0
                        } else  print $0
                }
        }

        END {
                if(DEFAULT_SESSION==1) {
			for(i=0;i<DEFAULT_SESSION_INDEX;i++) {
                                print DEFAULT_MSGS[i]
                        }
                        print MSG
                }
        }' $tmp_file`" > $file

        rm $tmp_file 			
	
	return
}

SUBNAME[30]="Uso de crontab irrestrito"
SUBCODE[30]="4033"
apply_30() {
	local file="/var/adm/cron/cron.allow"
	local cmd=""
        local content=""

	[ -z "$BASE_CRON_ALLOW" ] && {
		MISSED_VAR="BASE_CRON_ALLOW"
                unset file
                unset cmd
                unset content
		return 33
	}

	[ -a "$file" ] || cmd="rm $file"

        # selecting only the users defined on baseline that exist on system.
        base_users=`user_exists "$BASE_CRON_ALLOW"`
        [ -z "$base_users" ] && {
          echo "None of the users defined on baseline exist on system." >> $LOGF
          return $CODE_CONFORMITY
        }

	backupFile "$file" "data" "$cmd"

	for user in $base_users; do
		content="$user
$content"
	done

	setContent "$file" "$content"

        unset file
        unset cmd
        unset content

	return
}

SUBNAME[31]="Uso de at irrestrito"
SUBCODE[31]="4034"
apply_31() {
	local file="/var/adm/cron/at.allow"
	local cmd=""
	local content=""
	
	[ -z "$BASE_AT_ALLOW" ] && {
		MISSED_VAR="BASE_AT_ALLOW"
                unset file
                unset cmd
                unset content
		return 33
	}

	[ -a "$file" ] || cmd="rm $fie"

        # selecting only the users defined on baseline that exist on system.
        base_users=`user_exists "$BASE_AT_ALLOW"`
        [ -z "$base_users" ] && {
          echo "None of the users defined on baseline exist on system." >> $LOGF
          return $CODE_CONFORMITY
        }

	backupFile "$file" "data" "$cmd"

	for user in $base_users; do
		content="$user
$content"
	done

	setContent "$file" "$content"

        unset file
        unset cmd
        unset content

	return
}

SUBNAME[32]="Acesso a login gráfico irrestrito"
SUBCODE[32]="4035"
apply_32() {
	local file="/usr/dt/config/Xaccess"

	[ -f $file ] || {
	  MISSED_FILE=$local_file
	  return 34
	}

	grep -q -E '^[ \t]*\*[ \t]*CHOOSER[ \t]*BROADCAST' $file || return 22 
	grep -q -E '^#[ \t]*\*[ \t]*CHOOSER[ \t]*BROADCAST' $file && return 22 

	backupFile "$file" "data"

	tmp_file=`mktemp /tmp/correction.XXXXXX`
	sed 's/^\([ \t]\{0,\}\*[ \t]\{1,\}CHOOSER[ \t]\{1,\}BROADCAST[ \t]\{1,\}.*\)/# \1/' $file > $tmp_file

	cat $tmp_file > $file

  rm $tmp_file

	#setLine "$file" "^[[:blank:]]*\\\\*[[:blank:]]*CHOOSER[[:blank:]]+BROADCAST" "#"
	return
}

SUBNAME[33]="Tempo de aviso para alteração de senha indefinido"
SUBCODE[33]="4044"
apply_33() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_WARNTIME" ]; then
		MISSED_VAR="BASE_WARNTIME"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a pwdwarntime | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "pwdwarntime=${BASE_WARNTIME}"
		local val=`lssec -f $file -s default -a pwdwarntime | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_WARNTIME" ]; then

			chsec -f $file -s default -a "pwdwarntime=${BASE_WARNTIME}"
			local val=`lssec -f $file -s default -a pwdwarntime | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a pwdwarntime | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "pwdwarntime=${BASE_WARNTIME}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "pwdwarntime=${BASE_WARNTIME}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[34]="Número alto de tentativas de Login permitidas"
SUBCODE[34]="4045"
apply_34() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_RETRIES" ]; then
		MISSED_VAR="BASE_RETRIES"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a loginretries | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "loginretries=${BASE_RETRIES}"
		local val=`lssec -f $file -s default -a loginretries | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_RETRIES" ]; then

			chsec -f $file -s default -a "loginretries=${BASE_RETRIES}"
			local val=`lssec -f $file -s default -a loginretries | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a loginretries | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "loginretries=${BASE_RETRIES}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "loginretries=${BASE_RETRIES}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[35]="Possibilidade de implementação de senhas iguais ou parecidas em alteração"
SUBCODE[35]="4046"
apply_35() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_MINDIFF" ]; then
		MISSED_VAR="BASE_MINDIFF"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a mindiff | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "mindiff=${BASE_MINDIFF}"
		local val=`lssec -f $file -s default -a mindiff | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_MINDIFF" ]; then

			chsec -f $file -s default -a "mindiff=${BASE_MINDIFF}"
			local val=`lssec -f $file -s default -a mindiff | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a mindiff | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "mindiff=${BASE_MINDIFF}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "mindiff=${BASE_MINDIFF}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[36]="Tamanho de histórico de senhas pequeno ou inexistente"
SUBCODE[36]="4048"
apply_36() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_HISTSIZE" ]; then
		MISSED_VAR="BASE_HISTSIZE"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a histsize | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "histsize=${BASE_HISTSIZE}"
		local val=`lssec -f $file -s default -a histsize | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_HISTSIZE" ]; then

			chsec -f $file -s default -a "histsize=${BASE_HISTSIZE}"
			local val=`lssec -f $file -s default -a histsize | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a histsize | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "histsize=${BASE_HISTSIZE}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "histsize=${BASE_HISTSIZE}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[37]="Sessões idle"
SUBCODE[37]="4064"
apply_37() {
  fix_tmout /etc/profile "$BASE_TMOUT"
	return
}

SUBNAME[38]="Permissões de arquivos de auditagem incorretas"
SUBCODE[38]="4069"
apply_38() {
	setLogPerm
  return_code=$?
  [ "$INSTALL_FIX_AUDIT_SCRIPT" = "0" ] && install_fix_audit_script
	return $return_code
}

SUBNAME[39]="Umask de super-usuário não restritivo"
SUBCODE[39]="4070"
apply_39() {
	local file="/etc/security/user"
        local val

        val=`lssec -f $file -s root -a umask | awk -F= ' { print $2 } '`

	sysUser=`expr "$val" / 100`
        sysGroup=`expr "$val" / 10 % 10`
        sysOthers=`expr "$val" % 10`

	if [ "$sysUser" -ge 7 -a "$sysGroup" -ge 7 -a "$sysOthers" -ge 7 ]; then
		return 22
	fi

        backupFile "$file" "data"

        chsec -f $file -s root -a "umask=${BASE_RUMASK}"
        return
}

SUBNAME[40]="Aliases desnecessários"
SUBCODE[40]="4032"
apply_40() {
        local file=/etc/aliases

        which newaliases > /dev/null || return 22

        backupFile "$file" "data" "newaliases"
        setLine "$file" "^[^#|]*\\|" "#"

        newaliases
        return
}

SUBNAME[41]="Tamanho mínimo de senhas baixo ou não definido"
SUBCODE[41]="4043"
apply_41() {
	######################################################
	# Initializing variables
	######################################################
	local file="/etc/security/user"
	local userS_temp=`cat /etc/passwd | egrep -v "^[ \t]*#|^[ \t]*$" | awk -F":" '{ print $1 }' | sort -u`
	local vulnerable="no"
	######################################################

	######################################################
	# Checking the baseline's variable
	######################################################
	if [ -z "$BASE_MINLEN" ]; then
		MISSED_VAR="BASE_MINLEN"
		return 33
	fi
	######################################################

	######################################################
	# Backing up the target file
	######################################################
	backupFile "$file" "data"
	######################################################

	######################################################
	# Applying the default stanza only and getting the
	# result
	######################################################
	local val=`lssec -f $file -s default -a minlen | awk -F= '{ print $2 }'`

	if [ -z "$val" ]; then

		chsec -f $file -s default -a "minlen=${BASE_MINLEN}"
		local val=`lssec -f $file -s default -a minlen | awk -F= '{ print $2 }'`
		vulnerable="yes"

	else
		if [ "$val" != "$BASE_MINLEN" ]; then

			chsec -f $file -s default -a "minlen=${BASE_MINLEN}"
			local val=`lssec -f $file -s default -a minlen | awk -F= '{ print $2 }'`
			vulnerable="yes"
		fi
	fi
	######################################################

	######################################################
	# Applying all vulnerable stanzas
	######################################################
	for user_temp in ${userS_temp}; do

		local temp_val=`lssec -f $file -s $user_temp -a minlen | awk -F"=" '{ print $2 }'`

		if [ -n "temp_val" ] ; then

			if [ "$temp_val" != "$val" ]; then

				chsec -f $file -s $user_temp -a "minlen=${BASE_MINLEN}"
				vulnerable="yes"

			fi
		else
			chsec -f $file -s $user_temp -a "minlen=${BASE_MINLEN}"
			vulnerable="yes"
		fi
	done
	######################################################

	######################################################
	# Checking the return code
	######################################################
	if [ "$vulnerable" = "yes" ]; then

		unset vulnerable
		return
	else
		unset vulnerable
		return $CODE_CONFORMITY
	fi
	######################################################
}

SUBNAME[42]="Usuários reais com diretório home na raiz do sistema"
SUBCODE[42]="4054"
apply_42() {
  fix_home_directories
  return
}

SUBNAME[43]="Vulnerável a DNS Spoofing"
SUBCODE[43]="4065"
apply_43() {

  #found in lib/common
  fix_dns_spoofing

  if [ $? -eq 77 ]; then

    echo "  [-] Baseline nao definida para esse item." 

  fi

  return

}

SUBNAME[44]="\".\" em PATH de super-usuário"
SUBCODE[44]="4062"
apply_44() {

  #found in lib/common
  fix_invalid_PATH

  return

}

SUBNAME[45]="Comunidades SNMP padrão habilitadas"
SUBCODE[45]="4020"
apply_45() {

  #found in lib/AIX/include.sh
  snmp_fix_default_communities
  return

}

SUBNAME[46]="Habilitar Gerentes SNMP"
SUBCODE[46]="4077"
apply_46() {

  #found in lib/AIX/include.sh
  snmp_fix_managers
  return

}

SUBNAME[47]="Sudo use not being logged on syslog"
SUBCODE[47]="4072"
apply_47() {

        local file="/etc/sudoers"
        set_syslog_in_sudoers "$file"
        return
}

