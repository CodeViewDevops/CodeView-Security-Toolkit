#-------------
#SunOS Library
#-------------------------------------------------------------------
TARGET_OS="SunOS"
TECH_VER=1

. "$APP_PATH/lib/SunOS/include.sh"

#-------------------------------------------------------------------
BASE_IDS="1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 62 71 80 81" 

#special functions for Solaris 10
if [ "$revision" = "5.10" ] || [ "$revision" = "5.11" ]; then
  BASE_IDS="$BASE_IDS 48 49 50 51 52 53 54 55 56 57 58 59 60 61 67 68 69 70 71 80"
fi

NDD=`which ndd`

[ -n "$NDD" ] && {
  NDD_IP_LIST=`$NDD -get /dev/ip ? | $AWK '{ print $1 }'`
  NDD_TCP_LIST=`$NDD -get /dev/tcp ? | $AWK '{ print $1 }'`
}

check_ndd_module() {
  [ $# -lt 2 ] && return 1

  driver=$1
  parameter=$2

  case $driver in
    "/dev/ip") parameter_list=$NDD_IP_LIST;;
    "/etc/tcp") parameter_list=$NDD_TCP_LIST;;
    *) return 1;;
  esac

  printf "$parameter_list\n" | grep "$parameter" > /dev/null 2> /dev/null

  return $?
}

SUBNAME[1]="Disable system information displaying in /etc/motd"
SUBCODE[1]="2821"
apply_1() {

	# related files
	file="/etc/motd"
	cmd=""

	# initial checks
	[ -n "$BASE_BANNER" ] || {

		MISSED_VAR="BASE_BANNER"
		return ${CODE_MISSED_VAR}
	}

	if [ -f "$file" ]; then

		#Delete motd content
		if [ -n "$BASE_EMPTY_MOTD" -a "$BASE_EMPTY_MOTD" = "on" ]; then

			echo "" > "$file"
			return ${CODE_OK}
		else

			file_content=`cat $file >> "$LOGE"`

			[ "$file_content" = "$BASE_BANNER" ] && return ${CODE_CONFORMITY}

			backupFile "$file" "data"
			setContent "$file" "$BASE_BANNER"
			return ${CODE_OK}
		fi
	else

		return ${CODE_CONFORMITY}
	fi
}

SUBNAME[2]="Remove public writable files in /etc"
SUBCODE[2]="2806"
apply_2() {
    setEtcPerm
    return
}

SUBNAME[3]="Enable Cron restrictions"
SUBCODE[3]="2829"
apply_3() {

  cron_allow=/etc/cron.d/cron.allow
  cron_deny=/etc/cron.d/cron.deny

  file=/etc/cron.d/cron.allow
  cronContent=""
  cmd=""

  [ -z "$BASE_CRON_ALLOW" ] && [ -z "$BASE_CRON_DENY" ] && {
    MISSED_VAR="BASE_CRON_ALLOW OR BASE_CRON_DENY"
    return $CODE_MISSED_VAR
  }

  base_users=""

  if [ -f "$cron_allow" ]; then

    [ $verbosity ] && printf "    Fixing $cron_allow "
    printf "Fixing $cron_allow " >> "$LOGF"

    if [ -n "$BASE_CRON_ALLOW" ]; then
      [ $verbosity ] && printf "based on BASE_CRON_ALLOW\n"
      printf "based on BASE_CRON_ALLOW\n" >> "$LOGF"

      # selecting only the users defined on baseline that exist on system.
      base_users=`user_exists "$BASE_CRON_ALLOW"`
      [ -z "$base_users" ] && {
        echo "None of the users defined on baseline exist on system." >> $LOGF
        return $CODE_CONFORMITY
      }

      cronContent=`printf "$base_users\n" | tr " " "\n" >> "$LOGE"`
      in_accordance=0
      for user in $base_users; do
        grep "^$user" "$cron_allow" > /dev/null 2>> "$LOGE" || in_accordance=1
      done

      base_nusers=`printf "$cronContent\n" | wc -l 2>> "$LOGE"`
      cron_nusers=`cat "$cron_allow" | wc -l 2>> "$LOGE"`
      [ "$base_nusers" -lt "$cron_nusers" ] && {
        [ $verbosity ] && echo "    There are more users on $cron_allow than expected for baseline, fixing..."
        echo "There are more users on $cron_allow than expected for baseline, fixing..." >> "$LOGF"
        in_accordance=1
      }

      [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY 

      backupFile "$cron_allow" "data"
      setContent "$cron_allow" "$cronContent"

      return

    else

      if [ -n "$BASE_CRON_DENY" ]; then
        [ $verbosity ] && printf "based on BASE_CRON_DENY\n"
        printf "based on BASE_CRON_DENY\n" >> "$LOGF"

        # selecting only the users defined on baseline that exist on system.
        base_users=`user_exists "$BASE_CRON_DENY"`
        [ -z "$base_users" ] && {
          echo "None of the users defined on baseline exist on system." >> $LOGF
          return $CODE_CONFORMITY
        }

        in_accordance=0
        for user in $base_users; do
          grep "^$user$" "$cron_allow" > /dev/null 2>> "$LOGE" && {
            in_accordance=1
            denied_users="${denied_users} $user"
          }
        done

        [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY 

        [ -n "$denied_users" ] && {

          backupFile "$cron_allow" "data"

          for user in $denied_users; do
            tmp_file=`mktemp /tmp/correction.XXXXXX 2>> "$LOGE"`
            sed "/^${user}$/d" $cron_allow > $tmp_file 2>> "$LOGE"
            cat $tmp_file > $cron_allow 2>> "$LOGE"
            rm $tmp_file 2>> "$LOGE"
          done

          return $CODE_OK
        }
      fi
    fi
  else

    if [ -f "$cron_deny" ]; then
      [ $verbosity ] && printf "    Fixing $cron_deny "
      printf "Fixing $cron_deny " >> "$LOGF"

      if [ -n "$BASE_CRON_DENY" ]; then

        [ $verbosity ] && printf "based on BASE_CRON_DENY\n"
        printf "based on BASE_CRON_DENY\n" >> "$LOGF"

        base_users=`user_exists "$BASE_CRON_DENY"`
        [ -z "$base_users" ] && {
          echo "None of the users defined on baseline exist on system." >> $LOGF
          return $CODE_CONFORMITY
        }

        in_accordance=0
        cronContent=`printf "$base_users\n" | tr " " "\n" 2>> "$LOGE"`
        for user in $base_users; do
          grep "^$user" "$cron_deny" > /dev/null 2>> "$LOGE" || in_accordance=1
        done

        base_nusers=`printf "$cronContent\n" | wc -l 2>> "$LOGE"`
        cron_nusers=`cat "$cron_deny" | wc -l 2>> "$LOGE"`
        [ "$base_nusers" -lt "$cron_nusers" ] && {
          [ $verbosity ] && echo "    There are more users on $cron_deny than expected for baseline, fixing..."
          echo "There are more users on $cron_deny than expected for baseline, fixing..." >> "$LOGF"
          in_accordance=1
        }

        [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY 

        backupFile "$cron_deny" "data"
        setContent "$cron_deny" "$cronContent"

        return

      else

        [ -n "$BASE_CRON_ALLOW" ] && {

          [ $verbosity ] && printf "based on BASE_CRON_ALLOW\n"
          printf "based on BASE_CRON_ALLOW\n" >> "$LOGF"

          base_users=`user_exists "$BASE_CRON_ALLOW"`
          [ -z "$base_users" ] && {
            echo "None of the users defined on baseline exist on system." >> $LOGF
            return $CODE_CONFORMITY
          }

          in_accordance=0
          for user in $base_users; do
            grep "^$user$" "$cron_deny" > /dev/null 2>> "$LOGE" && {
              in_accordance=1
              allowed_users="${allowed_users} $user"
            }
          done

          [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY 

          [ -n "$allowed_users" ] && {

            backupFile "$cron_deny" "data"

            for user in $allowed_users; do
              tmp_file=`mktemp /tmp/correction.XXXXXX 2>> "$LOGE"`
              sed "/^${user}$/d" $cron_deny > $tmp_file 2>> "$LOGE"
              cat $tmp_file > $cron_deny 2>> "$LOGE"
              rm $tmp_file 2>> "$LOGE"
            done

            return $CODE_OK
          }


        }

      fi
    else
      if [ -n "$BASE_CRON_ALLOW" ]; then

        [ $verbosity ] && echo "    Creating $cron_allow based on BASE_CRON_ALLOW"
        echo "Creating $cron_allow based on $BASE_CRON_ALLOW" >> "$LOGF"

        base_users=`user_exists "$BASE_CRON_ALLOW"`
        [ -z "$base_users" ] && {
          echo "None of the users defined on baseline exist on system." >> $LOGF
          return $CODE_CONFORMITY
        }

        printf "$base_users\n" | tr " " "\n" > $cron_allow 2>> "$LOGE"

        return $CODE_OK
      else

        [ -n "$BASE_CRON_DENY" ] && {
          [ $verbosity ] && echo "    Creating $cron_deny based on BASE_CRON_DENY"
          echo "Creating $cron_deny based on $BASE_CRON_DENY" >> "$LOGF"

          base_users=`user_exists "$BASE_CRON_DENY"`
          [ -z "$base_users" ] && {
            echo "None of the users defined on baseline exist on system." >> $LOGF
            return $CODE_CONFORMITY
          }

          printf "$base_users\n" | tr " " "\n" > $cron_deny 2>> "$LOGE"
          return $CODE_OK
        }
      fi
    fi
  fi


}


SUBNAME[4]="Enable At restrictions"
SUBCODE[4]="2830"
apply_4() {
  file=/etc/cron.d/at.allow
  atContent=""
  base_users=""
  cmd=""

  [ -z "$BASE_AT_ALLOW" ] && return $CODE_CONFORMITY 

  base_users=`user_exists "$BASE_AT_ALLOW"`
  [ -z "$base_users" ] && {
    echo "None of the users defined on baseline exist on system." >> $LOGF
    return $CODE_CONFORMITY
  }

  if [ -f "$file" ]; then
    in_accordance=0

    for user in $base_users; do
      grep "^$user" "$file" > /dev/null 2>> "$LOGE" || {
        in_accordance=1
        atContent="$user
$atContent"
      }
    done

    [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY 

    backupFile "$file" "data"

  else

    for user in $base_users; do
      atContent="$user
$atContent"
    done

    backupFile "" "perm" "rm $file"

  fi

  setContent "$file" "$atContent"
  return
}


#FIXME - Precisa criar uma funcao que compare as permissoes para que esse item consiga avisar conformidade
SUBNAME[5]="Set temporary directories permission"
SUBCODE[5]="2803"
apply_5() {

    files="/tmp /var/tmp"

    in_accordance=0
    for f in $files; do
      ( \ls -ld $f | grep rwt 2>> "$LOGE" ) >> "$LOGE" 2>&1 && continue
      in_accordance=1
    done

    [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY

    backupFile "$files" "perm"

    for f in $files; do

      [ -d $f ] || continue
      ( \ls -ld $f 2>> "$LOGE" | grep rwt ) >> "$LOGE" 2>&1 && continue

      setPerm "$f" "1777"
      [ $? -eq $CODE_ERROR ] && return $CODE_ERROR
    done

    return $CODE_OK 
}


SUBCODE[6]="2854"
apply_6() {

  fix_tmout /etc/profile "$BASE_TMOUT"
  return

}

SUBNAME[7]="Remove public readable files in log directorires"
SUBCODE[7]="2805"
apply_7() {
    #find /var/log/* /var/adm/* -type f ! -perm 600 -ls
    #46149    3 -r--------   1 root     root         2828 Jul 18 16:02 /var/adm/lastlog
    #
    #lastlog tem a permissao correta mas esta aparecendo na lista
    #os arquivos devem ter a permissao 700
    setLogPerm
    return_code=$?
    [ "$INSTALL_FIX_AUDIT_SCRIPT" = "0" ] && install_fix_audit_script
    return $return_code
}

SUBNAME[8]="Remove public executable compilers in PATH"
SUBCODE[8]="2856"
apply_8() {

  [ "`solaris10_is_smallzone 2>> $LOGE`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  setCompilerPerm
  return
}

SUBNAME[9]="Remove SUID/SGID files in PATH"
SUBCODE[9]="2804"
apply_9() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE 

  # check if one of baseline variables are set
  [ -n "$BASE_SID_DENY" -o -n "$BASE_SID_ALLOW" ] || {
    MISSED_VAR="BASE_SID_DENY/ALLOW"
    return $CODE_MISSED_VAR 
  }

  setSid "/usr/ccs/bin /usr/ucb /bin /sbin /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin"
  return

}

SUBNAME[10]="Disable trust relationship"
SUBCODE[10]="2822"
apply_10() {
    setTrust
    return
}

SUBNAME[11]="Disable unnecessary inetd services"
SUBCODE[11]="2818"
apply_11() {

  	file=/etc/inetd.conf
  	ret_val=22

  	if [ "$revision" = "5.10" ] ; then
    
		apply_11_10
    		return
  	fi

  	# check if running inetd
  	proc=`ps -ef | grep inetd | grep -v grep | head -n 1 2>> "$LOGE"`
  	[ -n "$proc" ] || return $CODE_CONFORMITY 
  	[ -f "$file" ] || {
    	
		MISSED_FILE="$file"
    		return $CODE_MISSED_FILE
  	}

  	# For debug reasons
  	echo "    BASE_INETD_DENY=\"$BASE_INETD_DENY\""   >> "$LOGF"
  	echo "    BASE_INETD_ALLOW=\"$BASE_INETD_ALLOW\"" >> "$LOGF"


  	# check if has sshd running
  	has_ssh=0
  	ps -ef | grep sshd | grep -v grep >> "$LOGE" 2>&1 && has_ssh=1
  
  	echo "    Has SSH running (has_ssh) = $has_ssh" >> "$LOGF"

  	backupFile "$file" "data" # 'pkill -l inetd'

  	[ -n "$BASE_INETD_DENY" ] && {

    		echo "Changing $file..." 2>> "$LOGF"
    		[ $verbosity ] && echo "    Changing $file..."

    		in_accordance=0
    		target_services=""
    		for i in $BASE_INETD_DENY; do
      
			[ "$i" = "telnet" -a $has_ssh -eq 0 ] && {
        		
				echo "    SSH daemon not found. Telnet will not be disabled." 2>> "$LOGE"
        			[ $verbosity ] && echo "SSH daemon not found. Telnet will not be disabled."
        			continue
      			}

      			grep "^[ \t]*${i}[ \t]*" "$file" > /dev/null 2>> "$LOGE" || {

				in_accordance=1
        			target_services="${target_services} $i"
      			}

    		done

    		[ $in_accordance -eq 0 ] && return $CODE_CONFORMITY

    		for service in $target_services; do

                        	apply_service="0"
                                [ "$interactive" = "no" ] || {

                                	yn "            [*] Service to be stopped: \"${service}\". Apply?"
                                	apply_service="$?"
                                }

                                [ "$apply_service" -eq "1" ] && {

                                	continue
                                }
     
      				setLine "$file" "^[[:blank:]]*$i[[:blank:]]" "#"
      				[ $? -eq $CODE_ERROR ] && return $CODE_ERROR
    		done
		#    echo "    Reloading inetd configuration: " >> "$LOGF"
		#    [ $verbosity ] && echo_n "    Reloading inetd configuration: "
		#    pkill -l inetd 2>> "$LOGE" || {
		#      echo "not possible" >> "$LOGF"
		#      [ $verbosity ] && echo "not possible"
		#      return $CODE_ERROR 
		#    }

    		echo "ok" >> "$LOGF"
    		[ $verbosity ] && echo ok
    		return $CODE_OK 
  	}

  	[ -n "$BASE_INETD_ALLOW" ] || {
    
    		[ $verbosity ] && {
      
			echo "    Variable BASE_INETD_ALLOW is empty."
      			echo "    Disabling ALL inetd services..."
    		}

    		echo "    Variable BASE_INETD_ALLOW is empty." >> "$LOGF"
    		echo "    Disabling ALL inetd services..." >> "$LOGF"
  	}

  	# check if has sshd running
  	has_ssh=0
  	ps -ef | grep sshd | grep -v grep >> "$LOGE" 2>&1 && has_ssh=1

  	CHANGE=0
  	for i in `awk '/^[aA-zZ0-9]/ { print $1 }' $file 2>> "$LOGE"`; do
    
		[ "$i" = "telnet" -a $has_ssh -eq 0 ] && {
      		
			[ $verbosity] && echo "    SSH daemon not found. Telnet will not be disabled."
      			echo "    SSH daemon not found. Telnet will not be disabled." >> "$LOGF"
      			continue
    		}
    
		OK=0
    		for g in $BASE_INETD_ALLOW; do
      
			[ "$g" = "$i" ] && {
        	
				OK=1
        			break
      			}
    		done

    		[ $OK -eq 0 ] && {
 
                        apply_service="0"
                        [ "$interactive" = "no" ] || {

                               	yn "            [*] Service to be stopped: \"${i}\". Apply?"
                               	apply_service="$?"
                        }

                        [ "$apply_service" -eq "1" ] && {

                              	continue
                        }
      		
			CHANGE=1
      			setLine "$file" "^$i[[:blank:]]" "#"
      			[ $? -eq $CODE_ERROR ] && return $CODE_ERROR 
    		}

  	done

  	if [ $CHANGE -eq 1 ]; then
	#    echo_n "    Reloading inetd configuration: " >> "$LOGF"
	#    [ $verbosity ] && echo_n "    Reloading inetd configuration: "
	#    pkill -1 inetd 2>> "$LOGE" || {
	#      [ $verbosity ] && echo "not possible"
	#      echo "not possible" >> "$LOGF"
	#      return $CODE_ERROR 
	#    }
    		echo ok >> "$LOGF"
    		[ $verbosity ] && echo ok
    		return $CODE_OK 
  	else
    	
		# nothing done
    		return $CODE_CONFORMITY 
  	fi
}

apply_11_10() {
  
	ret_val=22
  	state=""
  	has_ssh=0
  	target_services=""

  	state=`svcs -H -v svc:/network/ssh:default 2>> "$LOGE" | awk ' { print $1 } ' 2>> "$LOGE"`

  	[ "$state" = "online" ] && has_ssh=1

  	if [ -n "$BASE_INETD_DENY" ] ; then
    
		in_accordance=0
    		for s in $BASE_INETD_DENY ; do
          
      			echo_n "Checking $s: " >> "$LOGF"
      			[ $verbosity ] && echo_n "    Checking $s: "

      			state=`svcs -p -H "$s" 2>> "$LOGE" | cut -d' ' -f1 2>> "$LOGE"`

      			[ $verbosity ] && echo "$state"
      			echo "$state" >> "$LOGF"

      			[ "$state" = "online" ] && {
        		
				target_services="${target_services} ${s}"
        			in_accordance=1
      			}
     
    		done

    		[ $in_accordance -eq 0 ] && return $CODE_CONFORMITY

    		rollback_cmd=""
    		for s in $target_services; do
 
                        apply_service="0"
                        [ "$interactive" = "no" ] || {

                               	yn "            [*] Service to be stopped: \"${s}\". Apply?"
                               	apply_service="$?"
                        }

                        [ "$apply_service" -eq "1" ] && {

                              	continue
                        }

      			svcadm disable "$s" >> $LOGE 2>&1

      			[ $? -eq "0" ] || {
          
				[ $verbosity ] && echo "    Error disabling $s"
          			echo "Error disabling $s" >> $LOGF
          			continue;
      			}

      			rollback_cmd="${rollback_cmd} svcadm enable \"$s\";"
    		done

    		backupFile "" "perm" "$rollback_cmd" 

    		return $CODE_OK

  	fi

 	[ -n "$BASE_INETD_ALLOW" ] || {

    		echo "    Variable BASE_INETD_ALLOW is empty." >> "$LOGF"
    		echo "    Disabling ALL inetd services..." >> "$LOGF"

    		[ $verbosity ] && {
      
			echo "    Variable BASE_INETD_ALLOW is empty."
      			echo "    Disabling ALL inetd services..."
    		}
  	}

  	CHANGE=0
  	rollback=""
  	for i in `inetadm | awk ' /^enabled/ { print $3 } ' 2>> $LOGE`; do
    
		[ "$i" = "svc:/network/telnet:default" -a $has_ssh -eq 0 ] && {
      		
			echo "SSH daemon not found. Telnet will not be disabled." >> "$LOGF"
      			[ $verbosity ] && echo "    SSH daemon not found. Telnet will not be disabled."
      			continue
    		}

    		OK=0
    		for g in $BASE_INETD_ALLOW; do
      
			[ "$g" = "$i" ] || { 
        	
				OK=1
        			break
      			}
    		done

    		[ $OK -eq 1 ] && {
 
                        apply_service="0"
                        [ "$interactive" = "no" ] || {

                               	yn "            [*] Service to be stopped: \"${i}\". Apply?"
                               	apply_service="$?"
                        }

                        [ "$apply_service" -eq "1" ] && {

                              	continue
                        }

      			svcadm disable "$i" >> $LOGE 2>&1

      			[ $? -eq "0" ] || {
        
				[ $verbosity ] && echo "   Error disabling $i"
        			echo "Error disabling $i" >> $LOGF
        			continue                                                                                            
      			}

      			rollback_cmd="${rollback_cmd} svcadm enable \"$s\";"
    		}

  	done

 	[ $CHANGE -ne 1 ] && return $CODE_CONFORMITY 
  	backupFile "" "perm" "$rollback_cmd"
  	return $CODE_OK
}


SUBNAME[12]="Disable executable stack"
SUBCODE[12]="2790"
apply_12() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/system

  [ -f "$file" ] || {
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  conf1=`sed -n "/^[ \t]\{0,\}set[ \t]\{1,\}noexec_user_stack[ \t]\{0,\}=[ \t]\{0,\}1/p" $file 2>> "$LOGE"`
  conf2=`sed -n "/^[ \t]\{0,\}set[ \t]\{1,\}noexec_user_stack_log[ \t]\{0,\}=[ \t]\{0,\}1/p" $file 2>> "$LOGE"`

  [ -n "$conf1" ] && [ -n "$conf2" ] && return $CODE_CONFORMITY

  backupFile "$file" "data"

  setLine "$file" "^[[:blank:]]*set noexec_user_stack=" "set noexec_user_stack=1" "stack=1"
  [ $? -eq $CODE_ERROR ] && return $CODE_ERROR 

  [ $verbosity ] && echo "    This action will only take effect after reboot"

  setLine "$file" "^[[:blank:]]*set noexec_user_stack_log=" "set noexec_user_stack_log=1" "stack_log=1"

  return
}

SUBNAME[13]="Disable .core files"
SUBCODE[13]="2791"
apply_13() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/system

  conf=`sed -n "/^[ \t]\{0,\}set[ \t]\{1,\}sys:coredumpsize[ \t]\{0,\}=[ \t]\{0,\}0/p" $file 2>> "$LOGE"`
  [ -n "$conf" ] && return $CODE_CONFORMITY

  backupFile "$file" "data"

  [ $verbosity ] && echo "    This action will only take effect after reboot"

  setLine "$file" "^[[:blank:]]*set sys:coredumpsize" "set sys:coredumpsize=0" "set sys:coredumpsize=0"
  return
}

SUBNAME[14]="Disable ip forwarding"
SUBCODE[14]="2792"
apply_14() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/notrouter
  file_S99net=/etc/rc3.d/S99net

  check_ndd_module "/dev/ip" "ip_forwarding"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_forwarding"
    return $CODE_NDD_ERROR
  }

  value=`$NDD -get /dev/ip ip_forwarding 2>> "$LOGE"`

  [ $value -eq 0 -a -f "$file" -a  -f "$file_S99net" ] && grep -q "$NDD -set /dev/ip ip_forwarding 0" "$file_S99net" && return $CODE_CONFORMITY 

  $NDD -set /dev/ip ip_forwarding 0 2>> "$LOGE"
  value=`$NDD -get /dev/ip ip_forwarding 2>> "$LOGE"`

  [ $value -ne 0 ] && return $CODE_ERROR
  
  backupFile "$file" "data" '$NDD -set /dev/ip ip_forwarding 1'

  touch $file 2>> "$LOGE" || {
    return $CODE_ERROR
  }

  setPerm "$file" "400"
  chown root $file

  if [ ! -e "$file_S99net" ]; then
    echo "$NDD -set /dev/ip ip_forwarding 0" > "$file_S99net"
  else
    tmp_file=`mktemp /tmp/correction.XXXXXX 2>> "$LOGE"`
    sed "/^$NDD -set \/dev\/ip ip_forwarding/d" $file_S99net > $tmp_file 2>> "$LOGE"
    cat $tmp_file > $file_S99net 2>> "$LOGE"
    echo "$NDD -set /dev/ip ip_forwarding 0" >> $file_S99net
    rm $tmp_file 2>> "$LOGE"
  fi

  return $CODE_OK

}

SUBNAME[15]="Disable directed broadcasts"
SUBCODE[15]="2797"
apply_15() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/rc3.d/S99net

  check_ndd_module "/dev/ip" "ip_forward_directed_broadcasts"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_forward_directed_broadcasts"
    return $CODE_NDD_ERROR
  }

  value=`$NDD -get /dev/ip ip_forward_directed_broadcasts 2>> "$LOGE"`

  conf=`sed -n "/^[ \t]\{0,\}ndd[ \t]\{1,\}-set[ \t]\{1,\}\/dev\/ip[ \t]\{1,\}ip_forward_directed_broadcasts[ \t]\{1,\}0/p" $file 2>> "$LOGE"`

  [ $value -eq 0 -a -x "$file" ] && [ -n "$conf" ] && return $CODE_CONFORMITY 

  $NDD -set /dev/ip ip_forward_directed_broadcasts 0 2>> "$LOGE"
  value=`$NDD -get /dev/ip ip_forward_directed_broadcasts 2>> "$LOGE"`

  [ $value -ne 0 ] && return $CODE_ERROR
  
  if [ -f "$file" ]; then
    backupFile "$file" "data" 'ndd -set /dev/ip ip_forward_directed_broadcasts 1'
  else
    backupFile "" "perm" 'ndd -set /dev/ip ip_forward_directed_broadcasts 1'
  fi

  setLine "$file" "^[[:blank:]]*ndd .* /dev/ip ip_forward_directed_broadcasts" "ndd -set /dev/ip ip_forward_directed_broadcasts 0" "0"
  RET=$?
  [ -x "$file" ] || setPerm "$file" "700" || {
    return $CODE_ERROR 
  }

  return $RET

}

SUBNAME[16]="Disable icmp echo broadcast responses"
SUBCODE[16]="2798"
apply_16() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/rc3.d/S99net

  check_ndd_module "/dev/ip" "ip_respond_to_echo_broadcast"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_respond_to_echo_broadcast"
    return $CODE_NDD_ERROR
  }

  value=`$NDD -get /dev/ip ip_respond_to_echo_broadcast 2>> "$LOGE"`

  conf=`sed -n "/^[ \t]\{0,\}ndd[ \t]\{1,\}-set[ \t]\{1,\}\/dev\/ip[ \t]\{1,\}ip_respond_to_echo_broadcast[ \t]\{1,\}0/p" $file 2>> "$LOGE"`

  [ $value -eq 0 -a -x "$file" ] && [ -n "$conf" ] && return $CODE_CONFORMITY 

  $NDD -set /dev/ip ip_respond_to_echo_broadcast 0 2>> "$LOGE"
  value=`$NDD -get /dev/ip ip_respond_to_echo_broadcast 2>> "$LOGE"`

  [ $value -ne 0 ] && return $CODE_ERROR
  
  backupFile "$file" "data" 'ndd -set /dev/ip ip_respond_to_echo_broadcast 1'
  setLine "$file" "^[[:blank:]]*ndd .* /dev/ip ip_respond_to_echo_broadcast" "ndd -set /dev/ip ip_respond_to_echo_broadcast 0" "ndd -set /dev/ip ip_respond_to_echo_broadcast 0"
  local RET=$?

  [ -x "$file" ] || setPerm "$file" "700" || return $CODE_ERROR 

  return $RET

}

SUBNAME[17]="Disable timestamp responses"
SUBCODE[17]="2800"
apply_17() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/rc3.d/S99net

  check_ndd_module "/dev/ip" "ip_respond_to_timestamp"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_respond_to_timestamp"
    return $CODE_NDD_ERROR
  }

  value=`$NDD -get /dev/ip ip_respond_to_timestamp 2>> "$LOGE"`

  conf=`sed -n "/^[ \t]\{0,\}ndd[ \t]\{1,\}-set[ \t]\{1,\}\/dev\/ip[ \t]\{1,\}ip_respond_to_timestamp[ \t]\{1,\}0/p" $file 2>> "$LOGE"`

  [ $value -eq 0 -a -x "$file" ] && [ -n "$conf" ] && return $CODE_CONFORMITY 

  $NDD -set /dev/ip ip_respond_to_timestamp 0 2>> "$LOGE"
  value=`$NDD -get /dev/ip ip_respond_to_timestamp 2>> "$LOGE"`

  [ $value -ne 0 ] && return $CODE_ERROR
  
  backupFile "$file" "data" 'ndd -set /dev/ip ip_respond_to_timestamp 1'
  setLine "$file" "^[[:blank:]]*ndd .* /dev/ip ip_respond_to_timestamp" "ndd -set /dev/ip ip_respond_to_timestamp 0" "ndd -set /dev/ip ip_respond_to_timestamp 0"
  RET=$?

  [ -x "$file" ] || setPerm "$file" "700" || return $CODE_ERROR 

  return $RET

}

SUBNAME[18]="Disable broadcast timestamp responses"
SUBCODE[18]="2801"
apply_18() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/rc3.d/S99net

  check_ndd_module "/dev/ip" "ip_respond_to_timestamp_broadcast"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_respond_to_timestamp_broadcast"
    return $CODE_NDD_ERROR
  }


  value=`$NDD -get /dev/ip ip_respond_to_timestamp_broadcast 2>> "$LOGE"`

  conf=`sed -n "/^[ \t]\{0,\}ndd[ \t]\{1,\}-set[ \t]\{1,\}\/dev\/ip[ \t]\{1,\}ip_respond_to_timestamp_broadcast[ \t]\{1,\}0/p" "$file" 2>> "$LOGE"`

  [ -n "$value" ] && [ "$value" -eq "0" ] && [ -x "$file" ] && [ -n "$conf" ] && return $CODE_CONFORMITY 
  $NDD -set /dev/ip ip_respond_to_timestamp_broadcast 0 2>> "$LOGE"

  [ $value -ne 0 ] && return $CODE_ERROR
  
  backupFile "$file" "data" "ndd -set /dev/ip ip_respond_to_timestamp_broadcast 1"
  setLine "$file" "^[[:blank:]]*ndd .* /dev/ip ip_respond_to_timestamp_broadcast" "ndd -set /dev/ip ip_respond_to_timestamp_broadcast 0" "ndd -set /dev/ip ip_respond_to_timestamp_broadcast 0"
  RET=$?

  [ -x "$file" ] || setPerm "$file" "700" || return $CODE_ERROR 

  return $RET

}

SUBNAME[19]="Disable pre-routed packets"
SUBCODE[19]="2802"
apply_19() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/rc3.d/S99net

  check_ndd_module "/dev/ip" "ip_forward_src_routed"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_forward_src_routed"
    return $CODE_NDD_ERROR
  }

  value=`$NDD -get /dev/ip ip_forward_src_routed 2>> "$LOGE"`

  conf=`sed -n "/^[ \t]\{0,\}ndd[ \t]\{1,\}-set[ \t]\{1,\}\/dev\/ip[ \t]\{1,\}ip_forward_src_routed[ \t]\{1,\}0/p" "$file" 2>> "$LOGE"`

  [ $value -eq 0 -a -x "$file" ] && [ -n "$conf" ] && return $CODE_CONFORMITY 

  $NDD -set /dev/ip ip_forward_src_routed 0 2>> "$LOGE"
  value=`$NDD -get /dev/ip ip_forward_src_routed 2>> "$LOGE"`

  [ $value -ne 0 ] && return $CODE_ERROR
  
  backupFile "$file" data 'ndd -set /dev/ip ip_forward_src_routed 1'
  setLine "$file" "^[[:blank:]]*ndd .* /dev/ip ip_forward_src_routed" "ndd -set /dev/ip ip_forward_src_routed 0" "^[ \t]*ndd -set /dev/ip ip_forward_src_routed 0"
  RET=$?

  [ -x "$file" ] || setPerm "$file" "700" || {
    return $CODE_ERROR 
  }

  return $RET

}

SUBNAME[20]="Set TCP_STRONG_ISS variable"
SUBCODE[20]="2799"
apply_20() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  file=/etc/default/inetinit

  [ -n "$BASE_TCPSTRONG" ] || {
    MISSED_VAR="BASE_TCPSTRONG"
    return $CODE_MISSED_VAR 
  }

  check_ndd_module "/dev/tcp" "tcp_strong_iss"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="tcp_strong_iss"
    return $CODE_NDD_ERROR
  }

  sun_version=`uname -a | egrep -o "[0-9]{1,2}\.[0-9]{1,2}"`
  sun_release=`echo $sun_version | cut -d"." -f2`

  ##############################################################################
  # Checking the Sun/Solaris release 
  # This item is not compatible if set to 2, when the release is smaller than 6
  # For example: 5.5, 5.4, 5.3 etc, are compatible only for 1
  ##############################################################################
  if [ "$sun_release" -gt 5 ]; then

  	value=`$NDD -get /dev/tcp tcp_strong_iss 2>> "$LOGE"`
  	conf=`sed -n "/^[ \t]\{0,\}TCP_STRONG_ISS[ \t]\{0,\}=[ \t]\{0,\}${BASE_TCPSTRONG}/p" "$file" 2>> "$LOGE"`
  	[ $value -eq $BASE_TCPSTRONG ] && [ -n "$conf" ] && return $CODE_CONFORMITY 

  	$NDD -set /dev/tcp tcp_strong_iss $BASE_TCPSTRONG 2>> "$LOGE"
  	value=`$NDD -get /dev/tcp tcp_strong_iss 2>> "$LOGE"`

  	[ $value -ne $BASE_TCPSTRONG ] && return $CODE_ERROR
  
	backupFile "$file" "data" "ndd -set /dev/tcp tcp_strong_iss $value"
  	setLine "$file" "^[[:blank:]]*TCP_STRONG_ISS[[:blank:]]*=" "TCP_STRONG_ISS=${BASE_TCPSTRONG}" "^[[:blank:]]*TCP_STRONG_ISS=${BASE_TCPSTRONG}"

  else

  	value=`$NDD -get /dev/tcp tcp_strong_iss 2>> "$LOGE"`
  	conf=`sed -n "/^[ \t]\{0,\}TCP_STRONG_ISS[ \t]\{0,\}=[ \t]\{0,\}1/p" "$file" 2>> "$LOGE"`
  	[ -n "$conf" ] && return $CODE_CONFORMITY 

  	$NDD -set /dev/tcp tcp_strong_iss 1 2>> "$LOGE"
  	value=`$NDD -get /dev/tcp tcp_strong_iss 2>> "$LOGE"`

  	[ $value -ne "1" ] && return $CODE_ERROR
  
	backupFile "$file" "data" "ndd -set /dev/tcp tcp_strong_iss $value"
  	setLine "$file" "^[[:blank:]]*TCP_STRONG_ISS[[:blank:]]*=" "TCP_STRONG_ISS=1" "^[[:blank:]]*TCP_STRONG_ISS=1"
  fi  
  ##############################################################################
  
  return
}

SUBCODE[21]="2807"
apply_21() {

    file=/etc/default/login

    [ -n "$BASE_UMASK" ] || {
        MISSED_VAR="BASE_UMASK"
        return $CODE_MISSED_VAR 
    }

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    user_umask=`sed -n 's/^[ \t]\{0,\}UMASK[ \t]\{0,\}=[ \t]\{0,\}\([0-9]\{1,\}\)/\1/p' "$file" 2>> "$LOGE"`
    [ "$user_umask" -ge "$BASE_UMASK" ] && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*UMASK=" "UMASK=$BASE_UMASK" "^[[:blank:]]*UMASK=$BASE_UMASK"
    return
}

SUBCODE[22]="2812"
apply_22() {

    file=/etc/default/login

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    conf=`sed -n "/^[ \t]\{0,\}SYSLOG_FAILED_LOGINS[ \t]\{0,\}=[ \t]\{0,\}0/p" "$file" 2>> "$LOGE"`
    [ -n "$conf" ] && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*SYSLOG_FAILED_LOGINS=" "SYSLOG_FAILED_LOGINS=0" "^[[:blank:]]*SYSLOG_FAILED_LOGINS=0"
    return
}

SUBCODE[23]="2858"
apply_23() {

    local file=/etc/default/login

    [ -n "$BASE_SLEEPTIME" ] || {
        MISSED_VAR="BASE_SLEEPTIME"
        return $CODE_MISSED_VAR 
    }

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    conf=`sed -n "/^[ \t]\{0,\}SLEEPTIME[ \t]\{0,\}=[ \t]\{0,\}${BASE_SLEEPTIME}/p" "$file" 2>> "$LOGE"`
    [ -n "$conf" ] && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*SLEEPTIME=" "SLEEPTIME=$BASE_SLEEPTIME" "^[[:blank:]]*SLEEPTIME=$BASE_SLEEPTIME"
    return
}

SUBCODE[24]="2862"
apply_24() {

    file=/etc/default/login

    [ -n "$BASE_RETRIES" ] || {
        MISSED_VAR="BASE_RETRIES"
        return $CODE_MISSED_VAR 
    }

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    grep "^[ \t]*RETRIES[ \t]*=[ \t]*${BASE_RETRIES}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*RETRIES=" "RETRIES=$BASE_RETRIES" "^[[:blank:]]*RETRIES=$BASE_RETRIES"
    return
}

SUBNAME[25]="Disable super user remote login"
SUBCODE[25]="2850"
apply_25() {

    file=/etc/default/login

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    grep "^[ \t]*CONSOLE[ \]*=[ \t]*/dev/console" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*CONSOLE=" "CONSOLE=/dev/console" "^[[:blank:]]*CONSOLE=/dev/console"
    return
}

SUBNAME[26]="Enable logging of super user login attempts"
SUBCODE[26]="2811"
apply_26() {

    file=/etc/default/login

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    grep "^[ \t]*SYSLOG[ \]*=[ \t]*YES" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*SYSLOG=" "SYSLOG=YES" "^[[:blank:]]*SYSLOG=YES"
    return
}

SUBCODE[27]="2857"
apply_27() {

    file=/etc/default/login

    [ -n "$BASE_TIMEOUT" ] || {
        MISSED_VAR="BASE_TIMEOUT"
        return $CODE_MISSED_VAR 
    }

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    grep "^TIMEOUT[ \t]*=[ \t]*${BASE_TIMEOUT}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*TIMEOUT=" "TIMEOUT=$BASE_TIMEOUT" "^[[:blank:]]*TIMEOUT=$BASE_TIMEOUT"
    return
}

SUBNAME[28]="Enable inetd logging"
SUBCODE[28]="2828"
apply_28() {


  [ "$revision" = "5.10" ] && {
    val=`svccfg -s /network/inetd:default  listprop defaults/tcp_trace | awk ' { print $3 } ' 2>> "$LOGE"`
    [ "$val" = "true" ] && return $CODE_CONFORMITY 

    backupFile "" "perm" "inetadm -M tcp_trace=false"

    inetadm -M tcp_trace=true 2>> "$LOGE"
    return $CODE_OK
  }

  file=/etc/rc2.d/S72inetsvc

  proc=`ps -ef | grep "/inetd" | grep -v grep | head -n 1 2>> "$LOGE"`

  # not running
  [ -n "$proc" ] || return $CODE_CONFORMITY 

  # check if has logging option
  expr "$proc" : '.*[-]t' >> "$LOGE" 2>&1 && return $CODE_CONFORMITY 

  backupFile "$file" "data" 'pkill inetd && /usr/sbin/inetd -s'

  setLine "$file" "^[[:blank:]]*/usr/sbin/inetd " "/usr/sbin/inetd -s -t" "[-]t"
  RET=$?

  if [ $RET -eq 0 ]; then
    inetd_pid=`ps -ef | grep "/inetd" | grep -v grep | head -n 1 | awk '{ print $2 }'`
    if [ -n "$inetd_pid" ]; then
      ( kill -9 $inetd_pid && /usr/sbin/inetd -s -t ) 2>> "$LOGF" || {
        return $CODE_ERROR
      }
      return $CODE_OK
    else 
      return $CODE_ERROR
    fi

  else
    return $RET
  fi
}

SUBCODE[29]="2836"
apply_29() {

    file=/etc/default/passwd

    [ -f "$file" ] || {
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    grep "^[ \t]*MAXWEEKS[ \t]*=[ \t]*${BASE_MAXWEEKS}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"

    fix_variable_configuration "MAXWEEKS" "$BASE_MAXWEEKS" "$file"

    rstatus=$?

    #Improving error message (used in apply_correction function)
    case $rstatus in

      33)
        MISSED_VAR="BASE_MAXWEEKS"
	;;
     34)
      MISSED_FILE="$file"
;;

    esac

    return $rstatus 

}

SUBCODE[30]="2837"
apply_30() {

  file=/etc/default/passwd

   [ -f "$file" ] || { 
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }    

  grep "^[ \t]*PASSLENGTH[ \t]*=[ \t]*${BASE_PASSLEN}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY
 
  backupFile "$file" "data"
 
  fix_variable_configuration "PASSLENGTH" "$BASE_PASSLEN" "$file"
 
  rstatus=$?

  #Improving error message (used in apply_correction function)
  case $rstatus in
 
    33)
      MISSED_VAR="BASE_PASSLEN"
      ;;
    34)
      MISSED_FILE="$file"
      ;;

  esac
 
  return $rstatus

}

SUBCODE[31]="2834"
apply_31() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
     MISSED_FILE="$file"
     return $CODE_MISSED_FILE
  }    

  grep "^[ \t]*MINWEEKS[ \t]*=[ \t]*${BASE_MINWEEKS}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY
 
  backupFile "$file" "data"
 
  fix_variable_configuration "MINWEEKS" "$BASE_MINWEEKS" "$file"
 
  rstatus=$?
 
  #Improving error message (used in apply_correction function)
  case $rstatus in
 
    33)
      MISSED_VAR="BASE_MINWEEKS"
      ;;
    34)
      MISSED_FILE="$file"
      ;;
 
  esac
 
  return $rstatus
 
}

SUBCODE[32]="2838"
apply_32() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }    

  grep "^[ \t]*WARNWEEKS[ \t]*=[ \t]*${BASE_WARNWEEKS}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY
 
  backupFile "$file" "data"
 
  fix_variable_configuration "WARNWEEKS" "$BASE_WARNWEEKS" "$file"
 
  rstatus=$?
 
  #Improving error message (used in apply_correction function)
  case $rstatus in
 
    33)
      MISSED_VAR="BASE_WARNWEEKS"
      ;;
    34)
      MISSED_FILE="$file"
      ;;
 
  esac
 
  return $rstatus


}

SUBNAME[33]="Lock system users account"
SUBCODE[33]="2840"
apply_33() {
    setNullpass
    return
}

SUBNAME[34]="Disable system information on FTP server banner"
SUBCODE[34]="2833"
apply_34() {

  file=/etc/default/ftpd

  file_exists=1
  if [ -f "$file" ]; then
    grep "^[ \t]*BANNER[ \t]*=[ \t]*\"\"" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY
    backupFile "$file" "data"
    setLine "$file" "^[[:blank:]]*BANNER=" "BANNER=\"\"" "^[[:blank:]]*BANNER=\"\""
    return 
  else
    backupFile "" "perm" "rm $file" 
    setContent "$file" "BANNER=\"\""
    return
  fi

}

SUBNAME[35]="Set superuser's home directory"
SUBCODE[35]="2847"
apply_35() {

    #setHome root /root
    fix_home_directories
    return

}

SUBNAME[36]="Disable system information on Telnet server banner"
SUBCODE[36]="2832"
apply_36() {

  file=/etc/default/telnetd

  banner=`sed -n "s/^[ \t]\{0,\}BANNER=\"\(${BASE_BANNER}\)\"[ \t]\{0,\}/\1/p" $file 2>> "$LOGE"`
  [ -n "$banner" ] && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*BANNER=" "BANNER=\"${BASE_BANNER}\"" "\"^[[:blank:]]*BANNER=${BASE_BANNER}\""
  return  

}

SUBCODE[37]="2827"
apply_37() {
  
  file=/etc/default/cron

  [ -z "$BASE_CRONPATH" ] && {
    MISSED_VAR="BASE_CRONPATH"
    return $CODE_BASE_CRONPATH
  }

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }    

  grep "^[ \t]*PATH[ \t]*=[ \t]*${BASE_CRONPATH}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*PATH=" "PATH=${BASE_CRONPATH}" "^[[:blank:]]*PATH=${BASE_CRONPATH}"
  return  

}

SUBNAME[38]="Enable Crontab logging"
SUBCODE[38]="2815"
apply_38() {
  
  file=/etc/default/cron

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }    

  grep "^[ \t]*CRONLOG[ \t]*=[ \t]*YES" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*CRONLOG=" "CRONLOG=YES" "^[[:blank:]]*CRONLOG=YES"
  return  

}

SUBNAME[39]="Enable SU logging"
SUBCODE[39]="2814"
apply_39() {
  
  file=/etc/default/su

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }    

  logging=`sed -n "/^[ \t]\{0,\}SYSLOG[ \t]\{0,\}=[ \t]\{0,\}YES/p" $file 2>> "$LOGE"`
  [ -n "$logging" ] && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*SYSLOG=" "SYSLOG=YES" "^[[:blank:]]SYSLOG=YES"
  return  

}

SUBNAME[40]="Enable login attempts logging"
SUBCODE[40]="2810"
apply_40() {

  file=/var/adm/loginlog

  [ -f $file ] && return $CODE_CONFORMITY 

  backupFile "" "perm" "rm $file"

  ( touch $file && chmod 600 $file && chgrp sys $file ) 2>> "$LOGE"
  return

}

SUBNAME[41]="Set /etc/cron.d files permission"
SUBCODE[41]="2808"
apply_41() {

  dir=/etc/cron.d

  [ -d $dir ] || return $CODE_CONFORMITY 

  \ls -ld $dir | grep "drwx[-]\{6\}" >> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$dir" "perm"
  chmod 700 $dir 2>> "$LOGE" || return $CODE_ERROR 
  return 0

}

SUBNAME[42]="Enable syslog service"
SUBCODE[42]="2809"
apply_42() {

  file=/etc/rc2.d/S74syslog

  ps -ef | grep syslogd | grep -v grep >> "$LOGE" 2>&1 && return $CODE_CONFORMITY 

  [ -x $file ] || {
    [ $verbosity ] && echo "    Init script /etc/rc2.d/S74syslog not found or not executable"
    echo "    Init script /etc/rc2.d/S74syslog not found or not executable" >> "$LOGF"
    return $CODE_ERROR 
  }

  backupFile "$file" "data" '/etc/rc2.d/S74syslog stop'

  echo "Running: $file start" >> "$LOGF"
  [ $verbosity ] &&  echo "    Running: $file start"
  $file start >> "$LOGE" 2>&1
  return

}

SUBNAME[43]="Disable Stop + A keyboard feature"
SUBCODE[43]="2786"
apply_43() {

  file=/etc/default/kbd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }    

  grep "^[ \t]*KEYBOARD_ABORT[ \t]*=[ \t]*disable" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"

  setLine "$file" "KEYBOARD_ABORT=" "KEYBOARD_ABORT=disable"
  return
}

SUBNAME[44]="Enable SU command logging"
SUBCODE[44]="2813"
apply_44() {

  file=/etc/default/su

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }    

  logging=`sed -n "/^[ \t]\{0,\}CONSOLE[ \t]\{0,\}=[ \t]\{0,\}\/dev\/console/p" $file 2>> "$LOGE"`
  [ -n "$logging" ] && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "CONSOLE=" "CONSOLE=/dev/console"
  return
}

SUBNAME[45]="Restrict graphical login access"
SUBCODE[45]="2831"
apply_45() {

  [ "`solaris10_is_smallzone`" = "true" ] && return $CODE_SUNOS_SMALLZONE

  files="/usr/dt/config/Xaccess /etc/dt/config/Xaccess"
  vuln_files=""
  file_count=2
  conformity_count=0

  for file in $files; do
    [ -f $file ] || {
      conformity_count=`expr $conformity_count + 1` 
      continue
    }

    grep "^\*" "$file" > /dev/null 2>> "$LOGE" || {
      conformity_count=`expr $conformity_count + 1` 
      continue
    }

    if [ -z "$vuln_files" ]; then
      vuln_files="$file"
    else
      vuln_files="$vuln_files $file"
    fi
  done

  [ $file_count -eq $conformity_count ] && return $CODE_CONFORMITY

  backupFile "$vuln_files" "data"
  for file in $vuln_files; do
    setLine "$file" "^\*" "#"
  done

  return
}

SUBNAME[46]="Disable \"bad\" RC services"
SUBCODE[46]="2817"
apply_46() {

  	[ -n $BASE_NOSERVICES ] || return $CODE_CONFORMITY 

  	BAD=""
  	for s in $BASE_NOSERVICES; do
    
		[ $verbosity ] && echo_n "    Checking $s: "
    		# store enabled([S][id][name]) scripts
    		if spath=`ls /etc/rc*.d/S[0-9]*${s} 2>> "$LOGE"`; then
      
                	apply_service="0"
                	[ "$interactive" = "no" ] || {

                		yn "            [*] Service to be stopped: \"${s}\". Apply?"
                		apply_service="$?"
                	}

                	[ "$apply_service" -eq "1" ] && {

                		continue
                	}

      			BAD="$spath $BAD"
    		fi
  	done
  
	[ $verbosity ] && echo
  	[ -n "$BAD" ] || return $CODE_CONFORMITY

  	for bad in $BAD; do
    
		new=`echo $bad | awk '{ sub(/S/, "K"); print }' 2>> "$LOGE"`
    		NEWNAME="$new $NEWNAME"
  	done

  	for bad in $BAD; do
    
		RESTART_CMD="$bad start; $RESTART_CMD"
  	done

  	backupFile "$BAD" "data" "rm -f $NEWNAME; $RESTART_CMD"

  	echo
  	echo "    Disabling services..."
  	for bad in $BAD; do
    
		[ $verbosity ] && echo "    Executing: $bad stop"
    		# stop services
    		$bad stop >> "$LOGE" 2>&1 || {
      		
			echo "    Problems stopping: $bad"
      			echo "    Check log file for more information"
      			echo
    		}
  	done

  	echo
  	echo "    Renaming init scripts..."
  	for bad in $BAD; do
    
		new=`echo $bad | awk '{ sub(/S/, "K"); print }' 2>> "$LOGE"`
    		[ $verbosity ] && echo "    Moving: $bad -> $new"
    		# rename files
    		mv $bad $new 2>> "$LOGE" || return $CODE_ERROR 
  	done

  	return $CODE_OK 
}

SUBCODE[47]="2851"
apply_47() {

  group=/etc/group
  su=/usr/bin/su
  su_dir=`dirname $su 2>> "$LOGE"`
  can_modify_su=0
  is_smallzone=`solaris10_is_smallzone`

  [ -f "$su" ] || {
    echo "File $su not found." 2>> "$LOGF"
    [ $verbosity ] && echo "    File $su not found."
    return $CODE_CONFORMITY 
  }

  [ -n "$BASE_PRIVGROUP" ] || {
    MISSED_VAR="BASE_PRIVGROUP"
    return $CODE_MISSED_VAR 
  }

  [ -n "$BASE_SU_USERS" ] || {
      MISSED_VAR="BASE_SU_USERS"
      return $CODE_MISSED_VAR 
  }

  [ "$is_smallzone" = "true" ] && {
    shared_dirs=`solaris10_smallzone_shared_dirs`

    for dir in $shared_dirs; do
      echo "$su_dir" | grep "^${dir}" > /dev/null 2>> "$LOGE" && {
        can_modify_su=1
        break
      }
    done
  }

  [ $can_modify_su -eq 1 ] && {
    echo "    Can't change permissions and modes of $su on Solaris Smallzone with $su_dir as a shared readonly directory."
    echo "Can't change permissions and modes of $su on Solaris Smallzone with $su_dir as a shared readonly directory." >> "$LOGF"
    return $CODE_ERROR
  }


  in_accordance=0
  su_owner=`ls -l $su | $AWK '{print $3}' 2>> "$LOGE"`
  su_group=`ls -l $su | $AWK '{print $4}' 2>> "$LOGE"`
  su_perm=`ls_to_chmod $su | $AWK '{print $2}' 2>> "$LOGE"`
  users=`$AWK -v G=$BASE_PRIVGROUP -F: ' $0 ~ "^" G ":" { printf $4; exit; }' $group 2>> "$LOGE"`

  if [ "$su_owner" != "root" ]; then 
    in_accordance=1
  else
    if [ "$su_group" != "$BASE_PRIVGROUP" ]; then
      in_accordance=1
    else
      if [ "$su_perm" != "u=rwxs,g=rx,o=" ]; then
        in_accordance=1
      else
        if [ -z "$users" ]; then
          in_accordance=1
        else

          n_base_users=`echo $BASE_PRIVGROUP | wc -l | sed 's/ //g' 2>> "$LOGE"`
          n_group_users=`echo $users | sed 's/,/\n/g' | wc -l | sed 's/ //g' 2>> "$LOGE"`

          if [ $n_group_users -gt $n_base_users ]; then
            in_accordance=1
          else
            group_users=`echo $users | sed 's/,/ /g' 2>> "$LOGE"`

            for user in $BASE_SU_USERS; do
              user_found=1
              for guser in $group_users; do
                [ "$guser" = "$user" ] && {
                  user_found=0
                  break
                }
              done

              [ $user_found -eq 1 ] && {
                in_accordance=1
                break
              }
            done
          fi
        fi
      fi
    fi
  fi

  [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY

  line="`for i in $BASE_SU_USERS; do echo_n $i,; done`"

  # check if group has any members already
  if [ -n "$users" ]; then
    O="$IFS"
    IFS=", "
    # test if someone of BASE_SU_USERS is already a member
    for u in $users; do
      for z in $BASE_SU_USERS; do
        [ "$u" = "$z" ] && continue
        NEW_BASE_SU_USERS="$z $NEW_BASE_SU_USERS"
      done
    done
    IFS="$O"
    line="`for i in $NEW_BASE_SU_USERS; do echo_n $i,; done`"
  else
    line=${line%,}
  fi


  grep "^$BASE_PRIVGROUP:" $group >> "$LOGE" || {
      groupadd $BASE_PRIVGROUP 2>> "$LOGE" || {
        [ $verbosity ] && echo "    Impossible to create group $BASE_PRIVGROUP."
        echo "    Impossible to create group $BASE_PRIVGROUP." >> "$LOGF"
        return $CODE_ERROR 
      }
  }

  begin=`$AWK -v G=$BASE_PRIVGROUP -F: ' $0 ~ "^" G ":" { printf $1":"$2":"$3":"; exit; }' $group 2>> "$LOGE"`
  line="${begin}${line}${users}"

  restore_cmd=`ls_to_chmod $su 2>> "$LOGE"`
  backupFile "$group" "data" "$restore_cmd"

  [ $verbosity ] && echo "    Changing permission and modes..."
  echo "Changing permission and modes..." >> "$LOGF"
  chown root:${BASE_PRIVGROUP} $su && chmod 4750 $su 2>> "$LOGE"

  [ $verbosity ] && echo "    Changing $group..."
  echo "Changing $group..." >> "$LOGF"
  setLine "$group" "^$BASE_PRIVGROUP:" "$line" "$line"

  return "$CODE_OK"

}

SUBNAME[48]=""
SUBCODE[48]="2700"
apply_48() {

    file=/etc/default/passwd

    [ -f "$file" ] || { 
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    [ -n "$BASE_HISTSIZE" ] || {
      MISSED_VAR="BASE_HISTSIZE"
      return $CODE_MISSED_VAR
    }

    grep "^[ \t]*HISTORY[ \t]*=[ \t]*${BASE_HISTSIZE}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"

    fix_variable_configuration "HISTORY" "$BASE_HISTSIZE" "$file"

    rstatus=$?

    #Improving error message (used in apply_correction function)
    case $rstatus in

      33)
        MISSED_VAR="BASE_HISTSIZE"
;;
      34)
       MISSED_FILE="$file"
;;

    esac

    return $rstatus 

}

SUBNAME[49]=""
SUBCODE[49]="2701"
apply_49() {

    file=/etc/default/passwd

    [ -f "$file" ] || { 
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    [ -n "$BASE_MINDIFF" ] || {
      MISSED_VAR="BASE_MINDIFF"
      return $CODE_MISSED_VAR
    }

    grep "^[ \t]*MINDIFF[ \t]*=[ \t]*${BASE_MINDIFF}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"

    fix_variable_configuration "MINDIFF" "$BASE_MINDIFF" "$file"

    rstatus=$?

    #Improving error message (used in apply_correction function)
    case $rstatus in

      33)
        MISSED_VAR="BASE_MINDIFF"
	;;
      34)
       MISSED_FILE="$file"
;;

    esac

    return $rstatus 
}

SUBNAME[50]=""
SUBCODE[50]="2702"
apply_50() {

    file=/etc/default/passwd

    [ -f "$file" ] || { 
      MISSED_FILE="$file"
      return $CODE_MISSED_FILE
    }

    [ -n "$BASE_MINALPHA" ] || {
      MISSED_VAR="BASE_MINALPHA"
      return $CODE_MISSED_VAR
    }

    grep "^[ \t]*MINALPHA[ \t]*=[ \t]*${BASE_MINALPHA}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

    backupFile "$file" "data"

    fix_variable_configuration "MINALPHA" "$BASE_MINALPHA" "$file"

    rstatus=$?

    #Improving error message (used in apply_correction function)
    case $rstatus in

      33)
        MISSED_VAR="BASE_MINALPHA"
	;;
      34)
       MISSED_FILE="$file"
;;

    esac

    return $rstatus 

}

SUBNAME[51]=""
SUBCODE[51]="2703"
apply_51() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  [ -n "$BASE_MAXREPEATS" ] || {
    MISSED_VAR="BASE_MAXREPEATS"
    return $CODE_MISSED_VAR
  }

  grep "^[ \t]*MAXREPEATS[ \t]*=[ \t]*${BASE_MAXREPEATS}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY
 
  backupFile "$file" "data"
 
  fix_variable_configuration "MAXREPEATS" "$BASE_MAXREPEATS" "$file"
 
  rstatus=$?
 
  #Improving error message (used in apply_correction function)
  case $rstatus in
 
    33)
      MISSED_VAR="BASE_MAXREPEATS"
      ;;
    34)
      MISSED_FILE="$file"
      ;;
 
  esac
 
  return $rstatus

}

SUBNAME[52]=""
SUBCODE[52]="2704"
apply_52() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  [ -n "$BASE_MINOTHER" ] || {
    MISSED_VAR="BASE_MINOTHER"
    return $CODE_MISSED_VAR
  }

  grep "^[ \t]*MINSPECIAL[ \t]*=[ \t]*${BASE_MINOTHER}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY
 
  backupFile "$file" "data"

  fix_variable_configuration "MINSPECIAL" "$BASE_MINOTHER" "$file"

  rstatus=$?

    #Improving error message (used in apply_correction function)
    case $rstatus in

      33)
        MISSED_VAR="BASE_MINOTHER"
	;;
      34)
       MISSED_FILE="$file"
;;

    esac

}

SUBNAME[53]=""
SUBCODE[53]="2705"
apply_53() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  [ -n "$BASE_MINDIGIT" ] || {
    MISSED_VAR="BASE_MINDIGIT"
    return $CODE_MISSED_VAR
  }

  mindigit=`sed -n "/^[ \t]\{0,\}MINDIGIT[ \t]\{0,\}=[ \t]\{0,\}${BASE_MINDIGIT}/p" $file 2>> "$LOGE"`
  [ -n "$mindigit" ] && return $CODE_CONFORMITY

  backupFile "$file" "data"

  fix_variable_configuration "MINDIGIT" "$BASE_MINDIGIT" "$file"

  rstatus=$?

  #Improving error message (used in apply_correction function)
  case $rstatus in
    33) MISSED_VAR="BASE_MINDIGIT" ;;
    34) MISSED_FILE="$file" ;;
  esac

}

SUBNAME[54]=""
SUBCODE[54]="2706"
apply_54() {

    file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  [ -n "$BASE_MINNONALPHA" ] || {
    MISSED_VAR="BASE_MINNONALPHA"
    return $CODE_MISSED_VAR
  }

  grep "^[ \t]*MINNONALPHA[ \t]*=[ \t]*${BASE_MINNONALPHA}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"

  fix_variable_configuration "MINNONALPHA" "$BASE_MINNONALPHA" "$file"

  rstatus=$?

  #Improving error message (used in apply_correction function)
  case $rstatus in
    33) MISSED_VAR="BASE_MINNONALPHA" ;;
    34) MISSED_FILE="$file" ;;
  esac

  return $rstatus 

}

SUBNAME[55]=""
SUBCODE[55]="2707"
apply_55() {

   file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  [ -n "$BASE_MINLOWER" ] || {
    MISSED_VAR="BASE_MINLOWER"
    return $CODE_MISSED_VAR
  }

  grep "^[ \t]*MINLOWER[ \t]*=[ \t]*${BASE_MINLOWER}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"

  fix_variable_configuration "MINLOWER" "$BASE_MINLOWER" "$file"

  rstatus=$?

  #Improving error message (used in apply_correction function)
  case $rstatus in
    33) MISSED_VAR="BASE_MINLOWER" ;;
    34) MISSED_FILE="$file" ;;
  esac

  return $rstatus 
}

SUBNAME[56]=""
SUBCODE[56]="2708"
apply_56() {

    file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  [ -n "$BASE_MINUPPER" ] || {
    MISSED_VAR="BASE_MINUPPER"
    return $CODE_MISSED_VAR
  }

  grep "^[ \t]*MINUPPER[ \t]*=[ \t]*${BASE_MINUPPER}" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"

  fix_variable_configuration "MINUPPER" "$BASE_MINUPPER" "$file"

  rstatus=$?

  #Improving error message (used in apply_correction function)
  case $rstatus in
    33) MISSED_VAR="BASE_MINUPPER" ;;
    34) MISSED_FILE="$file" ;;
  esac

  return $rstatus 

}

SUBNAME[57]=""
SUBCODE[57]="2709"
apply_57() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  grep "^[ \t]*NAMECHECK[ \t]*=[ \t]*YES" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*NAMECHECK=" "NAMECHECK=YES" "^NAMECHECK=YES"
  return
}

SUBNAME[58]=""
SUBCODE[58]="2710"
apply_58() {

  file=/etc/default/passwd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  grep "^[ \t]*WHITESPACE[ \t]*=[ \t]*YES" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*WHITESPACE=" "WHITESPACE=YES" "^WHITESPACE=YES"
  return
}

SUBNAME[59]=""
SUBCODE[59]="2711"
apply_59() {

  file=/etc/default/login

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  grep "^[ \t]*PASSREQ[ \t]*=[ \t]*YES" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY

  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*PASSREQ=" "PASSREQ=YES" "^PASSREQ=YES"
  return
}

SUBNAME[60]=""
SUBCODE[60]="2712"
apply_60() {

   file=/etc/security/policy.conf

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  grep "^[ \t]*CRYPT_DEFAULT[ \t]*=[ \t]*1" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY


  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*CRYPT_DEFAULT=" "CRYPT_DEFAULT=1" "^CRYPT_DEFAULT=1"
  return
}

SUBNAME[61]=""
SUBCODE[61]="2713"
apply_61() {

    file=/etc/default/syslogd

  [ -f "$file" ] || { 
    MISSED_FILE="$file"
    return $CODE_MISSED_FILE
  }

  grep "^[ \t]*LOG_FROM_REMOTE[ \t]*=[ \t]*NO" "$file" > /dev/null 2>> "$LOGE" && return $CODE_CONFORMITY


  backupFile "$file" "data"
  setLine "$file" "^[[:blank:]]*LOG_FROM_REMOTE=" "LOG_FROM_REMOTE=NO" "^LOG_FROM_REMOTE=NO"
  return
}

SUBCODE[62]="2796"
apply_62() {

  file="/etc/rc3.d/S99net"

  check_ndd_module "/dev/ip" "ip_forward_directed_broadcasts"
  [ $? -eq 1 ] && {
    MISSING_NDD_PARAM="ip_forward_directed_broadcasts"
    return $CODE_NDD_ERROR
  }

	#checking if the current version is compatible for this item
	$NDD -get /dev/tcp tcp_sack_permitted 1>/dev/null 2>/dev/null
	if [ "$?" -eq "0" ]; then

		check_ndd_module "/dev/tcp" "tcp_sack_permitted"
		[ $? -eq 1 ] && {

			MISSING_NDD_PARAM="tcp_sack_permitted"
			return $CODE_NDD_ERROR
		}
	else

		MISSING_NDD_PARAM="tcp_sack_permitted"
		return ${CODE_NDD_ERROR}
	fi

  in_accordance=0
  active=`$NDD -get /dev/ip ip_forward_directed_broadcasts`
  if [ "$active" != "${BASE_SACK}" ]; then
    in_accordance=1
  else
    conf=`sed -n "/^[ \t]\{0,\}ndd[ \t]\{1,\}-set[ \t]\{1,\}\/dev\/tcp[ \t]\{1,\}tcp_sack_permitted[ \t]\{1,\}${BASE_SACK}/p" $file 2>> "$LOGE"`
    [ -z "$conf" ] && in_accordance=1
  fi

  [ $in_accordance -eq 0 ] && return $CODE_CONFORMITY
  
  cmd="$NDD -set /dev/tcp tcp_sack_permitted ${BASE_SACK}"

  [ -z "$BASE_SACK" ] && {
    MISSED_VAR="BASE_SACK"
    return $CODE_MISSED_VAR 
  }

  $cmd > "$LOGE" 2>> "$LOGE"
  setLine "$file" "^[[:blank:]]*ndd .* /dev/tcp tcp_sack_permitted" "ndd -set /dev/tcp tcp_sack_permitted ${BASE_SACK}" "ndd -set /dev/tcp tcp_sack_permitted ${BASE_SACK}"

  return
}

#solaris X
SUBCODE[63]="2828"
apply_63() {
  file="/etc/inetd.conf"
  cmd="/usr/sbin/tcpd"

  [ -x $cmd ] || {
    echo "TCP Wrappers is not installed"
    return 127
  }

  backupFile "$file" "data"
  content=`awk cmd="$cmd" ' /^ *#/ || $6 == cmd || $3 != "tcp" && $3 != "tcp6" {
    print; 
    next
  }

  $6 ~ /sbin/ {
    sub($6,cmd); 
    print; 
    next
  }

  {
    sub($7, $6)
    sub($6,cmd);
    print
  } ' $file 2>> "$LOGE"`

  setContent "$file" "$content"
  return
}

SUBCODE[64]=""
apply_64() {
  ret_val=22

  for s in $SVCS_NOSERVICES; do
    [ $verbosity ] && echo_n "     Checking $s: "
    state=`svcs -p -H "$s" | cut -d' ' -f1 2>> "$LOGE"`

    if [ "$state" = "online" ] ; then
      [ $verbosity ] && echo "Executing: svcadm disable $c"
      echo "Executing svcadm disable $c" >> "$LOGF" 2>&1
      svcadm disable "$c" >> $LOGE 2>&1

      [ $? -eq "0" ] || {
        echo "Error disabling $s"
        echo "Error disabling $s" >> $LOGF
        continue;
      }
      ret_val=0
    fi
  done

  return $ret_val
}


SUBNAME[66]="Use Trusted DNS Servers"
SUBCODE[66]="2855"
apply_66 () {

  #found in lib/common
  fix_dns_spoofing
  return

}

SUBNAME[67]="Superuser's umask not restrictive"
SUBCODE[67]="4484"
apply_67 () {

  [ -z "$BASE_RUMASK" ] && {
    MISSED_VAR="BASE_RUMASK"
    return $BASE_RUMASK
  }

  root_home=`sed -n "/^root:/p" /etc/passwd | cut -d: -f6 2>> "$LOGE"`
  files="${root_home}/.profile ${root_home}/.bashrc ${root_home}/.login"
  directive="umask ${BASE_RUMASK}"
  look_for="umask"

  [ -d "$root_home" ] || {

    echo "Can't locate root home directory. Aborting correction for this item..." >> "$LOGF"
    [ $verbosity ] && echo "    [-] Can't locate root home directory. Aborting correction for this item..."
    return $CODE_ERROR 

  }

  #found in lib/common
  fix_irrestrict_su_umask "$files" "$directive" "$look_for"
  return

}

SUBNAME[68]="Specify a Valid Alias to Local Root"
SUBCODE[68]="4485"
apply_68 () {

    #found in lib/SunOS/include.sh
  fix_mail_root

  return

}

SUBNAME[69]="Avoid \".\"In Superuser's Path"
SUBCODE[69]="2852"
apply_69 () {

    #found in lib/common
  fix_invalid_PATH

  return

}

SUBNAME[70]="Disable Built-in Users’ Shells"
SUBCODE[70]="2841"
apply_70 () {
  #found in lib/common
  fix_invalid_user_shell
  return
}

SUBNAME[71]="Use of default SNMP Communities"
SUBCODE[71]="2816"
apply_71 () {

  # If all snmpd files are in accordance, the item is CODE_CONFORMITY.
  # If at least one file is fixed, the item is CODE_OK
  # If all snmpd files are missing, the item is CODE_MISSED_FILE
  # If all snmp functions return baseline variable missing, the item is CODE_MISSED_VAR
  # If all above fail and we have mixed return codes, the item is CODE_FAILURE

  in_accordance="false"
  fixed="false"
  missed_file="false"
  missed_var="false"

  snmp_sma_fix_default_communities
  rcode=$?

  if [ $rcode -eq $CODE_CONFORMITY ]; then
    in_accordance="true"
    missed_file="false"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_FILE ]; then
    in_accordance="false"
    missed_file="true"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_VAR ]; then
    in_accordance="false"
    missed_file="false"
    missed_var="true"
  else
    in_accordance="false"
    missed_file="false"
    missed_var="false"
    fixed="true"
  fi  

  snmp_fix_default_communities "/etc/snmpd/conf/snmpd.conf"
  rcode=$?

  if [ $rcode -eq $CODE_CONFORMITY ]; then
    in_accordance="true"
    missed_file="false"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_FILE ]; then
    in_accordance="false"
    missed_file="true"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_VAR ]; then
    in_accordance="false"
    missed_file="false"
    missed_var="true"
  else
    in_accordance="false"
    missed_file="false"
    missed_var="false"
    fixed="true"
  fi  

  if [ ! -f /etc/snmp/conf/snmpd.conf ]; then
    snmp_fix_default_communities "/etc/snmp/snmpd.conf"
    rcode=$?
  else
    snmp_fix_default_communities "/etc/snmp/conf/snmpd.conf"
    rcode=$?
  fi

  if [ $rcode -eq $CODE_CONFORMITY ]; then
    in_accordance="true"
    missed_file="false"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_FILE ]; then
    in_accordance="false"
    missed_file="true"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_VAR ]; then
    in_accordance="false"
    missed_file="false"
    missed_var="true"
  else
    in_accordance="false"
    missed_file="false"
    missed_var="false"
    fixed="true"
  fi  

  [ "$fixed" = "true" ] && return $CODE_OK
  [ "$in_accordance" = "true" ]  && return $CODE_CONFORMITY
  [ "$missed_var" ] && return $CODE_MISSED_VAR
  [ "$missed_file" ] && return $CODE_MISSED_FILE

  return $CODE_FAILURE

}

SUBNAME[80]="Restrict SNMP Access to Authorized Managers"
SUBCODE[80]="2903"
apply_80 () {

  # If all snmpd files are in accordance, the item is CODE_CONFORMITY.
  # If at least one file is fixed, the item is CODE_OK
  # If all snmpd files are missing, the item is CODE_MISSED_FILE
  # If all snmp functions return baseline variable missing, the item is CODE_MISSED_VAR
  # If all above fail and we have mixed return codes, the item is CODE_FAILURE

  in_accordance="false"
  fixed="false"
  missed_file="false"
  missed_var="false"

  snmp_sma_fix_managers
  rcode=$?

  if [ $rcode -eq $CODE_CONFORMITY ]; then
    in_accordance="true"
    missed_file="false"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_FILE ]; then
    in_accordance="false"
    missed_file="true"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_VAR ]; then
    in_accordance="false"
    missed_file="false"
    missed_var="true"
  else
    in_accordance="false"
    missed_file="false"
    missed_var="false"
    fixed="true"
  fi  

  snmp_fix_managers "/etc/snmpd/conf/snmpd.conf"
  rcode=$?

  if [ $rcode -eq $CODE_CONFORMITY ]; then
    in_accordance="true"
    missed_file="false"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_FILE ]; then
    in_accordance="false"
    missed_file="true"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_VAR ]; then
    in_accordance="false"
    missed_file="false"
    missed_var="true"
  else
    in_accordance="false"
    missed_file="false"
    missed_var="false"
    fixed="true"
  fi  

  snmp_fix_managers "/etc/snmp/conf/snmpd.conf"
  rcode=$?

  if [ $rcode -eq $CODE_CONFORMITY ]; then
    in_accordance="true"
    missed_file="false"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_FILE ]; then
    in_accordance="false"
    missed_file="true"
    missed_var="false"
  elif [ $rcode -eq $CODE_MISSED_VAR ]; then
    in_accordance="false"
    missed_file="false"
    missed_var="true"
  else
    in_accordance="false"
    missed_file="false"
    missed_var="false"
    fixed="true"
  fi  

  [ "$fixed" = "true" ] && return $CODE_OK
  [ "$in_accordance" = "true" ]  && return $CODE_CONFORMITY
  [ "$missed_var" ] && return $CODE_MISSED_VAR
  [ "$missed_file" ] && return $CODE_MISSED_FILE

  return $CODE_FAILURE

}

SUBNAME[81]="Sudo use not being logged on syslog"
SUBCODE[81]="2900"
apply_81() {

	local file
	local files="/usr/local/etc/sudoers
/etc/sudoers"
	local IFS="
"

	for file in ${files}; do

		[ -f "$file" ] && break
	done

        set_syslog_in_sudoers "$file"
        return
}
