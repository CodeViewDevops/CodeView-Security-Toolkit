#===  FUNCTION  ================================================================
#          NAME:  security_session_check
#   DESCRIPTION:  Check if there's a Security Session inside the file.
#    PARAMETERS:  $1 = filename
#       RETURNS:  64 = there is a session ; 65 = there isn't a session ; 
#                 1 = failure
#===============================================================================

SECURITY_TAG_BEGIN="@security_session_begin"
SECURITY_TAG_END="@security_session_end"

security_session_check () {

  filename=$1

  if [ -f "$filename" ]; then

    found=`grep "${SECURITY_TAG_BEGIN}" ${filename} 2>> "$LOGE"`

    if [ -z "$found" ]; then

      return 65

    else

      return 64

    fi

  else

    return 1

  fi

}


#===  FUNCTION  ================================================================
#          NAME:  security_session_add
#   DESCRIPTION:  Add a Security Session to an existing file.
#    PARAMETERS:  $1 = filename
#       RETURNS:  0 = success ; 1 = failure; 66 = has a sec session already
#===============================================================================

security_session_add () {

  filename=$1

  security_session_check $filename

  if [ $? -eq 64 ]; then

    return 66

  fi

  if [ -f "$filename" -a -w "$filename" ]; then

      echo "#============================== SECURITY SESSION ===============================" >> $filename
      echo "#=========== PLEASE DO *NOT* EDIT OR INPUT CODE BELOW THIS SESSION =============" >> $filename
    echo "#" >> $filename
      echo "# All the code below was generated by Baseline Application Scripts" >> $filename
    echo "#" >> $filename
    echo "#${SECURITY_TAG_BEGIN}" >> $filename
    echo "#${SECURITY_TAG_END}" >> $filename
    echo "#===============================================================================" >> $filename

    return 0

  else

    return 1
  
  fi


}


#===  FUNCTION  ================================================================
#          NAME:  security_session_add_directive_test
#   DESCRIPTION:  Check if there is necessity of directive addition on security
#   		  session.
#    PARAMETERS:  $1 = absolute file path
#    		  $2 = regex. If it be found on $1, the directive must be add.
#       RETURNS:  1 = failure ; 80 = directive not necessary ; 
#                 81 = directive necessary
#===============================================================================

security_session_add_directive_test () {

  [ $# -lt 2 ] && return 1

  filename=$1
  look_for=$2

  [ -f "$filename" ] || return 80

  security_session_check $filename
  has_sec_session=$?

  if [ $has_sec_session -eq 64 ]; then

    found=`sed "/${SECURITY_TAG_BEGIN}/,/${SECURITY_TAG_END}/p" $filename | sed -n "/${look_for}/p" 2>> "$LOGE"`

  else

    found=`sed -n "/${look_for}/p" $filename 2>> "$LOGE"`

  fi

  if [ -z "$found" ]; then

    return 81 

  else

    return 80

  fi

}


#===  FUNCTION  ================================================================
#          NAME:  security_session_add_directive
#   DESCRIPTION:  
#    PARAMETERS:  $1 = directive 
#                 $2 = absolute file path.
#                 $3 = (optional) If the function found this line, the directive 
#                 will be add in the security session. This parameter must be a 
#                 regex to be used in sed.
#       RETURNS:  0 = success ; 1 = failure ; 22 = add directive is not necessary
#===============================================================================

security_session_add_directive () {

  [ $# -lt 2 ] return $CODE_ERROR 

  cmd=$1
  filename=$2
  look_for=$3
  add_directive=81 

  [ -n "$look_for" ] && {
    security_session_add_directive_test "$filename" "$look_for"
    add_directive=$?

    if [ $add_directive -eq 80 ]; then

      return $CODE_CONFORMITY 

    fi
  } 

  if [ -f "$filename" -a -w "$filename" -a $add_directive -eq 81 ]; then

    #creating a security session on file if not exists already
    security_session_check $filename
    [ $? -eq 65 ] && security_session_add $filename || return $CODE_ERROR

    #Replacing white spaces and tabulations in [[:blank:]]\{1,\}
    cmd_regex=`printf $cmd | sed 's/[[:blank:]]/[[:blank:]]\\\{1,\\\}/g' 2>> "$LOGE"`

    #Looking if already exist the directive inside security session
    found=`sed -n "/${SECURITY_TAG_BEGIN}/,/${SECURITY_TAG_END}/p" $filename | sed -n "/${cmd_regex}/p" 2>> "$LOGE"`

    if [ -z "$found" ]; then

      tmp_file=`mktemp /tmp/secsess.XXXXXX 2>> "$LOGE"`
      sed "/${SECURITY_TAG_END}/i\\
${cmd}" $filename > $tmp_file 2>> "$LOGF"
      cat $tmp_file > $filename 2>> "$LOGE"
      rm $tmp_file 2>> "$LOGE"

    fi

  else
    
    return $CODE_ERROR 

  fi


}

#===  FUNCTION  ================================================================
#          NAME:  security_session_set_umask
#   DESCRIPTION:  -- 
#    PARAMETERS:  $1 = file (full path) ;
#                 $2 = umask su value ;
#                 $3 = umask user value ;
#       RETURNS:  0 = success; 1 = failure
#===============================================================================

security_session_set_umask () {

  filename=$1
  umask_su=$2
  umask_user=$3

  if [ $# -lt 3 ]; then

    return 1

  fi

  cmd="if \[ \`id -u\` != 0 \]; then umask ${umask_user}; else umask ${umask_su}; fi"
  regex="if \[ \`id -u\` != 0 \]; then umask [0-9]\{1,\}; else umask [0-9]\{1,\}; fi"

  if [ -f "$filename" -a -w "$filename" ]; then

    security_session_check $filename

    #creating a security session on file if not exists already
    if [ $? -eq 65 ]; then

      security_session_add $filename

    fi

        #Looking for umask definition inside security session
    umask_def=`sed -n "/@security_session_begin/,/@security_session_end/p" $filename | sed -n "/${regex}/p"`

    tmp_file=`mktemp /tmp/tmpfile.XXXXXX`

    if [ -z "$umask_def" ]; then

          #Adding a umask value
      sed "/${SECURITY_TAG_END}/i\ ${cmd}" $filename > $tmp_file

    else

      #Updating umask value
      sed "/${SECURITY_TAG_BEGIN}/,/${SECURITY_TAG_END}/s/${regex}/${cmd}/g" $filename  > $tmp_file

    fi

    cat $tmp_file > $filename
    rm $tmp_file

  else

    return 1

  fi

}
